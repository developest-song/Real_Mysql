< 인덱스 >

디스크 읽기 방식
데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 상당히 많다.

하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)
메모리와 디스크의 처리속도 10만 배 이상의 차이 / 메모리와 SSD 1000배 가량의 차이
한 번에 많은 데이터를 읽는 순차 I/O - SSD와 HDD 거의 비슷하거나 SSD가 조금 빠름
랜덤 I/O - SSD가 훨씬 빠름

랜덤 I/O, 순차 I/O 
(그림 p216)  HDD에서 순차 I/O는 디스크 기록을 위해 1번 시스템 콜 요청
랜덤 I/O는 3번 시스템콜을 요청 
-> 디스크의 헤드를 움직이는 횟수 
-> 순차가 랜덤보다 3배 빠르다

헤드의 유무로 원판을 가지지 않는 SSD는 랜덤, 순차 I/O 차이가 없을 것으로 예측하지만,
실제로 랜덤I/O는 순차 I/O보다 전체 스루풋이 떨어진다.
** 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.(쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미)

인덱스 레인지 스캔 - 랜덤 I/O 
풀 테이블 스캔 - 순차 I/O (큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다) // 데이터 웨어하우스, 통계 작업

인덱스란
책의 맨 끝 찾아보기 - 인덱스
책의 내용 - 데이터 파일
페이지 번호 - 레코드의 주소
책의 ㄱㄴㄷ정렬 - 인덱스의 정렬 보관

SortedList - 인덱스 (저장되는 값을 항상 정렬된 상태로 유지하는 자료 구조)
ArrayList - 데이터 파일 (저장된 순서대로 별도의 정렬 없이 그대로 저장)

인덱스가 많은 테이블은 INSERT, UPDATE, DELETE 문장의 처리가 느려진다. BUT, SELECT는 매우 빠르게 처리

인덱스는 INSERT, UPDATE, DELETE 성능을 희생하고 읽기 속도를 높이는 기능 




