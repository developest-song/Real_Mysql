<쿼리 작성 및 최적화>

쿼리 작성과 연관된 시스템 변수
대소문자 구분, 문자열 표기 방법 등과 같은 SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라진다. 

SQL 모드
sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
* sql_mode 시스템 변수 설정 값들은 SQL 문장 작성 규칙뿐만 아니라 MySQL 서버 내부적으로 자동 실행되는 데이터 타입 변환 및 기본값 제어 등과 
관련된 옵션도 가지고 있다. 그래서 일단 MySQL 서버에 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 가능한 한 변수의 내용을 변경하지 않는 것이 좋다.
그리고 하나의 복제 그룹에 속한 모든 MySQL 서버들은 동일한 sql_mode 시스템 변수를 유지하는게 좋다. 

STRICT_ALL_TABLES & STRICT_TRANS_TABLES
Mysql서버에서 INSERT나 UPDATE 문자으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행한다. 이때 타입이 적절히 변환되기
어렵거나 칼럼에 저장될 값이 없거나 값의 길이가 칼럼의 최대 길이보다 큰 경우 Mysql 서버가 INSERT, UPDATE문장을 계속 실행할지, 아니면 에러를 발생시킬지를 결정한다.
STRICT_TRANS_TABLES 옵션은 InnoDB 같은 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용하며,
STRICT_ALL_TABLES 옵션은 트랜잭션 지원 여부와 무관하게 모든 스토리지 엔진에 대해 엄격한 모드를 적용한다. 

ANSI_QUOTES
Mysql에서는 문자열 값(리터럴)을 표현하기 위해 홑따옴표, 쌍따옴표를 동시에 사용할 수 있다.
하지만 Oracle의 경우 홑따옴표를 문자열 값 표기시, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 구분하는 용도로만 사용한다. 
ANSI_QUOTES사용시 Oracle과 같이 표기한다.

ONLY_FULL_GROUP_BY
Mysql의 쿼리에서는 GROUP BY 절에 포함되지 않은 칼럼이더라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다.
위의 시스템 변수 사용시 SQL 문법에 제한을 주게 된다. 8.0부터는 해당 변수의 활성화가 기본값이다.

PIPE_AS_CONCAT
Mysql에서는 || 는 OR 연산자와 같은 의미로 사용된다. PIPE_AS_CONCAT을 사용 시 Oracle과 같이 문자열 연결 연산자로 사용할 수 있다.

PAD_CHAR_TO_FULL_LENGTH
Mysql에서는 CHAR 타입이라고 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환된다. 하지만 CHAR 타입의 칼럼값을 가져올 떄 뒤쪽의 공백이 제거되지
않고 반환돼야 한다면 sql_mode 시스템 설정에 PAD_CHAR_TO_FULL_LENGTH를 추가하면 된다. 

NO_BACKSLASH_ESCAPES
Mysql에서도 일반적인 프로그래밍 언어에서처럼 역슬래시 문자를 이스케이프 문자로 사용할 수 있다. 해당 변수 사용시 이스케이프 용도로 사용할 수 없다.

IGNORE_SPACE
Mysql에서는 스토어드 프로시저나 함수의 이름 뒤에 공백이 있으면 "스토어드 프로시저나 함수가 없습니다"라는 에러가 출력될 수도 있다.
Mysql에서는 스토어드 프로시저나 함수명과 괄호 사이에 있는 공백까지도 스토어드 프로시저나 함수의 이름으로 간주한다. 이 동작 방식이 기본 모드이므로 몇 번이고 함수가
있는지 확인하기도 한다. sql_mode 시스템 변수에 IGNORE_SPACE를 추가하면 프로시저나 함수명과 괄호 사이의 공백은 무시한다. IGNORE_SPACE 옵션은 Mysql 서버의 
내장 함수에만 적용되며, 옵션 활성화 시 Mysql의 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없다.

REAL_AS_FLOAT
Mysql 서버에서는 부동 소수점 타입은 FLOAT과 DOUBLE 타입이 지원되는데, REAL 타입은 DOUBLE 타입의 동의어로 사용된다. 하지만 REAL_AS_FLOAT 모드가 활성화 시
Mysql 서버는 REAL이라는 타입이 FLOAT 타입의 동의어로 바뀐다.

NO_ZERO_IN_DATE & NO_ZERO_DATE
이 두 옵션이 활성화될 시 DATE, DATETIME 타입의 칼럼에 "2020-00-00" OR "0000-00-00"과 같은 잘못된 날짜를 저장하는 것이 불가능해진다.

ANSI
위의 여러가지 옵션을 조합해서 SQL표준에 맞게 동작하게 만들어준다
ANSI모드는 (REAL_AS_FLOAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY) 모드의 조합으로 구성된 모드다.

TRADITIONAL
STRICT_ALL_TABLES & STRICT_TRANS_TABLES과 비슷하지만 조금 더 엄격한 방식으로 작동한다.
(STRICT_ALL_TABLES, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION)모드의 조합으로 구성된 모드다.
TRADITIONAL 모드가 활성화되면 TRADITIONAL 모드가 아닐 때 경고로 처리되던 상황이 모두 에러로 바뀌고 SQL 문장은 실패한다.

영문 대소문자 구분
Mysql 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다. 이는 Mysql의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.
즉, 윈도우에 설치된 Mysql에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
lower_case_table_names
-> 1로 설정 시 모두 소문자로 저장, 대소문자 구분 x
-> 0 DB나 테이블명에 대해 대소문자 구분
-> 2 (Win, Mac) 저장은 대소문자 구분 Mysql 쿼리에서는 대소문자를 구분하지 안흥ㅁ

Mysql 예약어
생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(`)나 쌍따옴표로 감싸야한다.
테이블 생성 시 테스트를 위해 `를 사용하지 않고 만드는게 좋다. 에러로 알려주기 때문이다

매뉴얼의 SQL 문법 표기를 읽는 방법 (p6)
대문자로 표현된 단어는 모두 키워드를 의미한다. 키워드는 대소문자를 특별히 구분하지 않고 사용할 수 있다.
이탤릭체로 표현한 단어는 사용자가 선택해서 작성하는 토큰을 의미한다. 대부분 테이블명이나 칼럼명 또는 표현식을 사용한다. 
이 항목이 SQL 키워드나 식별자가 아니라면 하단에 따로 상세한 문법을 설명해 준다.

대괄호 [] 는 해당 키워드나 표현식 자체가 선택 사항, 문법적인 오류가 발생하지 않는다.
파이프 | 는 해당 목록 중 단 하나만 선택해서 사용할 수 있음을 나타낸다.
중괄호 {} 괄호 내의 아이템 중에서 반드시 하나르 사용해야 하는 경우를 의미한다.
... 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미한다.

Mysql 연산자와 내장 함수 

리터럴 표기법 문자열

문자열
SQL표준 (') Mysql (") 사용가능 ex) WHERE dept_no ="d001";

문자열 값에 홑따옴표가 포함돼 있을 때 
SQL표준 - 홑따옴표를 두 번 연속해서 입력하면 된다
Mysql - 쌍따옴표, 혼따옴표 혼합

식별자가 키워드와 충돌할 때
Oracle, PostgreSQL은 대괄호나 쌍따옴표로 충돌을 피함
Mysql은 백틱으로 감싸서 피한다

숫자
문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 Mysql 서버가 문자열 값을 숫자 값으로 자동 변환한다. 
하지만 이처럼 숫자 값과 문자열 값을 비교할 때는 한 가지 주의할 사항이 있다. 
Mysql은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
ex) WHERE string_column=10001;   의 경우 주어진 상숫값이 숫자 값이고 비교 칼럼이 문자열이라 string_column을 숫자로 변환해서 비교해야 하므로 인덱스가
있더라도 사용을 못하거나 쿼리 자체가 실패할 수도 있다.

날짜
다른 DBMS에서 날짜 타입을 비교하거나 INSERT하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하다. 하지만 Mysql에서는 정해진 형태의 날짜 포맷으로
표기하면 Mysql서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.

불리언
BOOL, BOLLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다.
false, true의 값을 넣어도 조회할 시 0, 1로 나옴 (정수로 매핑해서 사용하기 때문에)
불리언 타입을 사용하고 싶다면 ENUM 타입으로 관리하는 것이 조금 더 명확하다.

Mysql 연산자

동등 비교 =, <=>
<=>의 경우 NULL<=>NULL 을 1을 반환하고 NULL<=>1 을 0을 반환한다. NULL-Safe 비교 연산자라고 한다.

부정 비교 !=, <>

NOT 연산자 !

AND(&&), OR(||) 연산자
오라클에서 ||를 문자열 결합 연산자로 사용한다. 오라클에서 Mysql로 마이그레이션할 경우 문제가 생길 수 있다. 
이땐 PIPE_AS_CONCAT을 설정하면 된다.
* AND는 OR보다 우선순위가 높다

나누기(/, DIV) 나머지(%, MOD) 연산자
나누기 - /   몫의 정수 부분 - DIV    나머지 - % 또는 MOD

REGEXP 연산자
RLIKE와 REGEXP는 똑같은 비교를 수행하는 연산자다.
ex) select 'abc' REGEXP '^[x-z]';  // abc 문자열이 x,y,z 중의 문자로 시작하는지 검증

대표적 심벌
^ 문자열의 시작  
$ 문자열의 끝 
[] 문자중 하나 
() 문자열의 그룹 ex) (xyz)    'xyz'가 있는지 확인
| 문자열 중 하나 ex) "abc|xyz"     'abc' or 'xyz' 중 확인
. 어떠한 문자든지 1개의 문자 표시
* 이 기호 앞에 표시된 정규 표현식이 0또는 1번 이상 반복
+ 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복
? 이 기호 앞에 표시된 정규 표현식이 0또는 1번만 올 수 있다.

REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다. 
가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 사용하는 것이 좋다.

LIKE 연산자
인덱스를 이용해 처리할 수도 있다. 
정규 표현식을 검사하는 것이 아니라 어떤 상수 문자열이 있는지 없는지 정도를 판단하는 연산자다. 
사용할 수 있는 와일드카드가 "%", "_" 전부이다. 
& 0 또는 1개 이상의 모든 문자에 일치(문자의 내용과 관계없이)
_ 정확히 1개의 모든 문자에 일치(문자의 내용과 관계없이)

%나 _를 비교하고 싶을 경우
SELECT 'a%' LIKE 'a/%' ESCAPE '/';     // result 1
LIKE 연산자는 와일드카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있지만 앞이라면 사용할 수 없다. (인덱스 풀 스캔 방식 사용)

BETWEEN 연산자
다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의할 점이 있다.
select * from dept_emp
 where dept_no between 'd003' and 'd005' 
   and emp_no=10001;
pk(dept_no, emp_no)이 있을 경우 BETWEEN을 사용하면 emp_no=10001을 통해 비교 범위를 줄이는 역할을 할 수 없다.
IN 연산자의 처리 방법은 동등 비교 연산자와 비슷하여 같은 형태로 인덱스를 사용한다. 그에 반해 BETWEEN은 > <비교를 묶어 놓은 것이므로 연산 방법이 다르다.
** BETWEEN 부분을 dept_no in ('d003','d004','d005') 와 같이 바꾸면 emp_no=10001 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있다.

예전 버전의 Mysql에서는 BETWEEN 연산자를 IN 연산자로 변경하기 위해서는 dept_no in ('d003','d004','d005') 조건으로 만들어야 했다
하지만 8.0부터는 IN (subquery) 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.

IN 연산자
IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다. 범위 검색이 아닌 여러 번의 동등 비교로 실행하기에 일반적으로 빠르게 처리된다.
1) 상수가 사용된 경우 - IN(?,?,?)
2) 서브쿼리가 사용된 경우 - IN(select .. from .. )

상수일 때는 매우 빠르게 쿼리가 처리된다.
Mysql 8.0 이전 버전에서는 풀 테이블 스캔을 했던 경우 (튜플 사용)
where (dept_no, emp_no) IN (('d001',10017),('d002',10144),('d003',10054));
8.0부터는 튜플 그대로 사용해도 인덱스를 최적으로 사용할 수 있게 개선됐다.

IN (subquery)는 8.0전까지는 최적화가 불안했고, 8.0부터는 IN (subquery)와 같은 세미 조인의 최적화가 많이 안정화됐다.

NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문이다.
* NOT IN 연산자가 프라이머리 키와 비교될 때 가끔 쿼리의 실행 계획에 인덱스 레인지 스캔이 표시되는 경우가 있다. 하지만 이는 InnoDB 테이블에서 프라이머리
키가 클러스터링 키이기 때문일 뿐 실제 IN과 같이 효율적으로 실행된다는 것을 의미하지는 않는다.

Mysql 내장함수

IFNULL(NULL, 1) NULL이면 1반환

ISNULL(0) NULL 인지 아닌지 

NOW()

**SYSDATE() : SLEEP(2)와 같이 사용됐을 때 영향을 받는다. 
SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다. 
ex) WHERE emp_no=10001 AND from_date>SYSDATE(); 의 경우 <pk는 emp_no, from_date> emp_no만 index를 사용한다. SYSDATE로 인하여 사용하지 못한다.

이미 sysdate() 함수를 사용하고 있다면 Mysql 서버의 설정파일에 sysdate-is-now 시스템 변수를 넣어서 활성화하는 것이 이 같은 문제점을 제거하는
빠른 해결책이다. 

DATE_FORMAT(NOW(), '%Y-%m-%d')

STR_TO_DATE(NOW(), '%Y-%m-%d')
문자열을 DATETIME 타입으로 변환할 때 사용

DATE_ADD(NOW(), INTERVAL 1 DAY)
DATE_SUB(NOW(), INTERVAL 1 DAY)
DAY자리에 대신 사용할 수 있는 단위 
YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MICROSECOND, QUARTER(분기), WEEK

UNIX_TIMESTAMP()
'1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수
인자가 없을 경우 현재 날짜, 시간의 타임스탬프 값을 전달

FROM_UNIXTIME()
인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.

TIMESTAMP 타입은 4바이트 숫자 타입으로 저장되기 때문에 '1970-01-01 00:00:01' ~ '2038-01-09 03:14:07' 까지의 날짜 값만 가능하다.

RPAD LPAD
문자열의 좌측, 우측 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수. 
ex) RPAD('Cloee', 10, '_') -> Cloee_____
    LPAD('123',6,'0') -> 000123

RTRIM LTRIM TRIM
문자열의 좌측, 우측에 연속된 공백문자(space, newline, tab)를 제거하는 함수. TRIM은 양쪽 다 수행한다.

CONCAT
여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수, 인자 개수 제한이 없다. CAST() 함수를 이용해 숫자를 문자열로 변환하여 사용하는 편이 안전하다.
ex) CONCAT('A','B',CAST(1 AS CHAR)) -> AB1

CONCAT_WS(',','A','B') -> A,B (첫 인자의 구분자가 들어간다)

GROUP BY 문자열 결합(GROUP_CONCAT) 
그룹 함수 중 하나이다. 주로 GROUP BY와 함께 사용하며, GROUP BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어낸다. 
값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하다.
ex)
SELECT GROUP_CONCAT(dept_no) FROM departments;
-> d009,d005,d002 ...
SELECT GROUP_CONCAT(dept_no SEPARATOR '|') FROM departments;
-> d009|d005|d002 ...
SELECT GROUP_CONCAT(dept_no ORDER BY emp_no DESC) FROM departments; // 정렬 후 연결(함수 내에서 정의된 ORDER BY는 쿼리 전체적으로 설정값과 무관하다)
SELECT GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC) FROM departments; // 중복 제거 및 정렬 후 연결

GROUP_CONCAT() 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 
지정된 크기를 초과할 경우 경고 메시지가 발생하며 GUI 도구(TOAD, SQLyog)를 이용할 경우 단순히 경고만 발생하고, JDBC로 실행할 경우에는 ERROR로 취급되어
쿼리를 실패하기에 GROUP_CONCAT()의 결과가 지정된 버퍼 크기를 초과하지 않게 주의해야 한다.
group_concat_max_len 시스템 변수로 메모리 버퍼의 크기를 조정할 수 있다. default는 1KB이다.
8.0부터는 용도에 맞게 래터럴 조인이나 윈도우 함수를 이용할 수 있다. (p34)

CASE WHEN THEN END (SWITCH와 비슷한 용도)

CAST,CONVERT 
PrePared Statement를 제외하면 SQL은 텍스트 기반으로 작동하기 때문에 SQL에 포함된 모든 입력값은 문자열처럼 취급된다. 명시적으로 타입의 변환이 필요할 때
CAST()를 사용하면 되며, CONVER() 도 거의 비슷하며 함수의 인자 사용 규칙만 조금 다르다.
CAST() - DATE, TIME, DATETIME, BINARY, CHAR, DECIMAL, SIGNED INTEGER, UNSIGNED INTEGER
ex) CAST('1234' AS SIGNED INTEGER)
CONVERT()
1) 타입을 변환하는 용도 ex) CONVERT(1-2, UNSIGNED)
2) 문자열의 문자 집합을 변환하는 용도 ex) CONVERT('ABC' USING 'utf8mb4')

이진값과 16진수 문자열 변환 
HEX() 함수는 이진값을 사람이 읽을 수 있는 형태의 16진수의 문자열(HEX String)로 변환하는 함수
UNHEX() 함수는 16진수의 문자열을 읽어서 이진값으로 변환하는 함수다. 이진값 = 바이너리 값

암호화 및 해시 함수
MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달한 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수다.
SHA() - SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환한다.
SHA2() - SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환한다.
MD5() - 메시지 다이제스트 알고리즘을 사용해 128비트 해시 값을 반환한다.

함수들 모두 사용자의 비밀번호와 같은 암호화가 필요한 정보를 인코딩하는 데 사용되며, 특히 MD5() 함수는 말그대로 입력된 문자열의 길이를 줄이는(Digest) 용도로도
사용된다. SHA, MD5 두 함수의 출력 값은 16진수 문자열 형태이기 떄문에 저장하려면 저장 공간이 각각 20바이트와 16바이트의 두 배로 필요하다. 
그리고 SHA2 함수는 사용된 인자 값에 따라 출력되는 해시 값의 길이가 달라지므로 사용된 이자의 두 배가 필요하다. 
그래서 암호화된 값을 저장해 두기 위해 
MD5() - CHAR(32)
SHA() - CHAR(40) 의 타입을 필요로 한다.
저장공간을 원래의 16바이트, 20바이트로 줄이고 싶다면 CHAR, VARCHAR가 아닌 BINARY, VARBINARY 형태의 타입에 저장하면 된다.
이 때는 칼럼의 타입을 BINARY(16) or (20)으로 정의하고 MD5(), SHA() 함수의 결과를 UNHEX() 함수를 이용해 이진값으로 변환해서 저장하면 된다.
BINARY 타입에 저장된 이진값을 사람이 읽을 수 있는 16진수 문자열로 다시 되돌릴 떄는 HEX() 함수를 사용하면 된다. 예제 (p40)

















