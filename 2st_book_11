<쿼리 작성 및 최적화>

쿼리 작성과 연관된 시스템 변수
대소문자 구분, 문자열 표기 방법 등과 같은 SQL 작성 규칙은 MySQL 서버의 시스템 설정에 따라 달라진다. 

SQL 모드
sql_mode라는 시스템 설정에는 여러 개의 값이 동시에 설정될 수 있다.
* sql_mode 시스템 변수 설정 값들은 SQL 문장 작성 규칙뿐만 아니라 MySQL 서버 내부적으로 자동 실행되는 데이터 타입 변환 및 기본값 제어 등과 
관련된 옵션도 가지고 있다. 그래서 일단 MySQL 서버에 사용자 테이블을 생성하고 데이터를 저장하기 시작했다면 가능한 한 변수의 내용을 변경하지 않는 것이 좋다.
그리고 하나의 복제 그룹에 속한 모든 MySQL 서버들은 동일한 sql_mode 시스템 변수를 유지하는게 좋다. 

STRICT_ALL_TABLES & STRICT_TRANS_TABLES
Mysql서버에서 INSERT나 UPDATE 문자으로 데이터를 변경하는 경우 칼럼의 타입과 저장되는 값의 타입이 다를 때 자동으로 타입 변경을 수행한다. 이때 타입이 적절히 변환되기
어렵거나 칼럼에 저장될 값이 없거나 값의 길이가 칼럼의 최대 길이보다 큰 경우 Mysql 서버가 INSERT, UPDATE문장을 계속 실행할지, 아니면 에러를 발생시킬지를 결정한다.
STRICT_TRANS_TABLES 옵션은 InnoDB 같은 트랜잭션을 지원하는 스토리지 엔진에만 엄격한 모드를 적용하며,
STRICT_ALL_TABLES 옵션은 트랜잭션 지원 여부와 무관하게 모든 스토리지 엔진에 대해 엄격한 모드를 적용한다. 

ANSI_QUOTES
Mysql에서는 문자열 값(리터럴)을 표현하기 위해 홑따옴표, 쌍따옴표를 동시에 사용할 수 있다.
하지만 Oracle의 경우 홑따옴표를 문자열 값 표기시, 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 구분하는 용도로만 사용한다. 
ANSI_QUOTES사용시 Oracle과 같이 표기한다.

ONLY_FULL_GROUP_BY
Mysql의 쿼리에서는 GROUP BY 절에 포함되지 않은 칼럼이더라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING 절에 사용할 수 있다.
위의 시스템 변수 사용시 SQL 문법에 제한을 주게 된다. 8.0부터는 해당 변수의 활성화가 기본값이다.

PIPE_AS_CONCAT
Mysql에서는 || 는 OR 연산자와 같은 의미로 사용된다. PIPE_AS_CONCAT을 사용 시 Oracle과 같이 문자열 연결 연산자로 사용할 수 있다.

PAD_CHAR_TO_FULL_LENGTH
Mysql에서는 CHAR 타입이라고 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환된다. 하지만 CHAR 타입의 칼럼값을 가져올 떄 뒤쪽의 공백이 제거되지
않고 반환돼야 한다면 sql_mode 시스템 설정에 PAD_CHAR_TO_FULL_LENGTH를 추가하면 된다. 

NO_BACKSLASH_ESCAPES
Mysql에서도 일반적인 프로그래밍 언어에서처럼 역슬래시 문자를 이스케이프 문자로 사용할 수 있다. 해당 변수 사용시 이스케이프 용도로 사용할 수 없다.

IGNORE_SPACE
Mysql에서는 스토어드 프로시저나 함수의 이름 뒤에 공백이 있으면 "스토어드 프로시저나 함수가 없습니다"라는 에러가 출력될 수도 있다.
Mysql에서는 스토어드 프로시저나 함수명과 괄호 사이에 있는 공백까지도 스토어드 프로시저나 함수의 이름으로 간주한다. 이 동작 방식이 기본 모드이므로 몇 번이고 함수가
있는지 확인하기도 한다. sql_mode 시스템 변수에 IGNORE_SPACE를 추가하면 프로시저나 함수명과 괄호 사이의 공백은 무시한다. IGNORE_SPACE 옵션은 Mysql 서버의 
내장 함수에만 적용되며, 옵션 활성화 시 Mysql의 내장 함수는 모두 예약어로 간주되어 테이블이나 칼럼의 이름으로 사용될 수 없다.

REAL_AS_FLOAT
Mysql 서버에서는 부동 소수점 타입은 FLOAT과 DOUBLE 타입이 지원되는데, REAL 타입은 DOUBLE 타입의 동의어로 사용된다. 하지만 REAL_AS_FLOAT 모드가 활성화 시
Mysql 서버는 REAL이라는 타입이 FLOAT 타입의 동의어로 바뀐다.

NO_ZERO_IN_DATE & NO_ZERO_DATE
이 두 옵션이 활성화될 시 DATE, DATETIME 타입의 칼럼에 "2020-00-00" OR "0000-00-00"과 같은 잘못된 날짜를 저장하는 것이 불가능해진다.

ANSI
위의 여러가지 옵션을 조합해서 SQL표준에 맞게 동작하게 만들어준다
ANSI모드는 (REAL_AS_FLOAT, PIPE_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE, ONLY_FULL_GROUP_BY) 모드의 조합으로 구성된 모드다.

TRADITIONAL
STRICT_ALL_TABLES & STRICT_TRANS_TABLES과 비슷하지만 조금 더 엄격한 방식으로 작동한다.
(STRICT_ALL_TABLES, STRICT_TRANS_TABLES, NO_ZERO_IN_DATE, NO_ZERO_DATE, ERROR_FOR_DIVISION_BY_ZERO, NO_ENGINE_SUBSTITUTION)모드의 조합으로 구성된 모드다.
TRADITIONAL 모드가 활성화되면 TRADITIONAL 모드가 아닐 때 경고로 처리되던 상황이 모두 에러로 바뀌고 SQL 문장은 실패한다.

영문 대소문자 구분
Mysql 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다. 이는 Mysql의 DB나 테이블이 디스크의 디렉터리나 파일로 매핑되기 때문이다.
즉, 윈도우에 설치된 Mysql에서는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제에서는 대소문자를 구분한다.
lower_case_table_names
-> 1로 설정 시 모두 소문자로 저장, 대소문자 구분 x
-> 0 DB나 테이블명에 대해 대소문자 구분
-> 2 (Win, Mac) 저장은 대소문자 구분 Mysql 쿼리에서는 대소문자를 구분하지 안흥ㅁ

Mysql 예약어
생성하는 데이터베이스나 테이블, 칼럼의 이름을 예약어와 같은 키워드로 생성하면 해당 칼럼이나 테이블을 SQL에서 사용하기 위해 항상 역따옴표(`)나 쌍따옴표로 감싸야한다.
테이블 생성 시 테스트를 위해 `를 사용하지 않고 만드는게 좋다. 에러로 알려주기 때문이다

매뉴얼의 SQL 문법 표기를 읽는 방법 (p6)
대문자로 표현된 단어는 모두 키워드를 의미한다. 키워드는 대소문자를 특별히 구분하지 않고 사용할 수 있다.
이탤릭체로 표현한 단어는 사용자가 선택해서 작성하는 토큰을 의미한다. 대부분 테이블명이나 칼럼명 또는 표현식을 사용한다. 
이 항목이 SQL 키워드나 식별자가 아니라면 하단에 따로 상세한 문법을 설명해 준다.

대괄호 [] 는 해당 키워드나 표현식 자체가 선택 사항, 문법적인 오류가 발생하지 않는다.
파이프 | 는 해당 목록 중 단 하나만 선택해서 사용할 수 있음을 나타낸다.
중괄호 {} 괄호 내의 아이템 중에서 반드시 하나르 사용해야 하는 경우를 의미한다.
... 표기는 앞에 명시된 키워드나 표현식의 조합이 반복될 수 있음을 의미한다.

Mysql 연산자와 내장 함수 

리터럴 표기법 문자열

문자열
SQL표준 (') Mysql (") 사용가능 ex) WHERE dept_no ="d001";

문자열 값에 홑따옴표가 포함돼 있을 때 
SQL표준 - 홑따옴표를 두 번 연속해서 입력하면 된다
Mysql - 쌍따옴표, 혼따옴표 혼합

식별자가 키워드와 충돌할 때
Oracle, PostgreSQL은 대괄호나 쌍따옴표로 충돌을 피함
Mysql은 백틱으로 감싸서 피한다

숫자
문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 칼럼이면 Mysql 서버가 문자열 값을 숫자 값으로 자동 변환한다. 
하지만 이처럼 숫자 값과 문자열 값을 비교할 때는 한 가지 주의할 사항이 있다. 
Mysql은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
ex) WHERE string_column=10001;   의 경우 주어진 상숫값이 숫자 값이고 비교 칼럼이 문자열이라 string_column을 숫자로 변환해서 비교해야 하므로 인덱스가
있더라도 사용을 못하거나 쿼리 자체가 실패할 수도 있다.

날짜
다른 DBMS에서 날짜 타입을 비교하거나 INSERT하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하다. 하지만 Mysql에서는 정해진 형태의 날짜 포맷으로
표기하면 Mysql서버가 자동으로 DATE나 DATETIME 값으로 변환하기 때문에 복잡하게 STR_TO_DATE() 같은 함수를 사용하지 않아도 된다.

불리언
BOOL, BOLLEAN이라는 타입이 있지만 사실 이것은 TINYINT 타입에 대한 동의어일 뿐이다.
false, true의 값을 넣어도 조회할 시 0, 1로 나옴 (정수로 매핑해서 사용하기 때문에)
불리언 타입을 사용하고 싶다면 ENUM 타입으로 관리하는 것이 조금 더 명확하다.

Mysql 연산자

동등 비교 =, <=>
<=>의 경우 NULL<=>NULL 을 1을 반환하고 NULL<=>1 을 0을 반환한다. NULL-Safe 비교 연산자라고 한다.

부정 비교 !=, <>

NOT 연산자 !

AND(&&), OR(||) 연산자
오라클에서 ||를 문자열 결합 연산자로 사용한다. 오라클에서 Mysql로 마이그레이션할 경우 문제가 생길 수 있다. 
이땐 PIPE_AS_CONCAT을 설정하면 된다.
* AND는 OR보다 우선순위가 높다

나누기(/, DIV) 나머지(%, MOD) 연산자
나누기 - /   몫의 정수 부분 - DIV    나머지 - % 또는 MOD

REGEXP 연산자
RLIKE와 REGEXP는 똑같은 비교를 수행하는 연산자다.
ex) select 'abc' REGEXP '^[x-z]';  // abc 문자열이 x,y,z 중의 문자로 시작하는지 검증

대표적 심벌
^ 문자열의 시작  
$ 문자열의 끝 
[] 문자중 하나 
() 문자열의 그룹 ex) (xyz)    'xyz'가 있는지 확인
| 문자열 중 하나 ex) "abc|xyz"     'abc' or 'xyz' 중 확인
. 어떠한 문자든지 1개의 문자 표시
* 이 기호 앞에 표시된 정규 표현식이 0또는 1번 이상 반복
+ 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복
? 이 기호 앞에 표시된 정규 표현식이 0또는 1번만 올 수 있다.

REGEXP 연산자를 문자열 칼럼 비교에 사용할 때 REGEXP 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다. 
가능하다면 데이터 조회 범위를 줄일 수 있는 조건과 함께 사용하는 것이 좋다.

LIKE 연산자
인덱스를 이용해 처리할 수도 있다. 
정규 표현식을 검사하는 것이 아니라 어떤 상수 문자열이 있는지 없는지 정도를 판단하는 연산자다. 
사용할 수 있는 와일드카드가 "%", "_" 전부이다. 
& 0 또는 1개 이상의 모든 문자에 일치(문자의 내용과 관계없이)
_ 정확히 1개의 모든 문자에 일치(문자의 내용과 관계없이)

%나 _를 비교하고 싶을 경우
SELECT 'a%' LIKE 'a/%' ESCAPE '/';     // result 1
LIKE 연산자는 와일드카드 문자가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있지만 앞이라면 사용할 수 없다. (인덱스 풀 스캔 방식 사용)

BETWEEN 연산자
다른 비교 조건과 결합해 하나의 인덱스를 사용할 때 주의할 점이 있다.
select * from dept_emp
 where dept_no between 'd003' and 'd005' 
   and emp_no=10001;
pk(dept_no, emp_no)이 있을 경우 BETWEEN을 사용하면 emp_no=10001을 통해 비교 범위를 줄이는 역할을 할 수 없다.
IN 연산자의 처리 방법은 동등 비교 연산자와 비슷하여 같은 형태로 인덱스를 사용한다. 그에 반해 BETWEEN은 > <비교를 묶어 놓은 것이므로 연산 방법이 다르다.
** BETWEEN 부분을 dept_no in ('d003','d004','d005') 와 같이 바꾸면 emp_no=10001 조건도 작업 범위를 줄이는 용도로 인덱스를 이용할 수 있다.

예전 버전의 Mysql에서는 BETWEEN 연산자를 IN 연산자로 변경하기 위해서는 dept_no in ('d003','d004','d005') 조건으로 만들어야 했다
하지만 8.0부터는 IN (subquery) 형태로 작성하면 옵티마이저가 세미 조인 최적화를 이용해 더 빠른 쿼리로 변환해서 실행한다.

IN 연산자
IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다. 범위 검색이 아닌 여러 번의 동등 비교로 실행하기에 일반적으로 빠르게 처리된다.
1) 상수가 사용된 경우 - IN(?,?,?)
2) 서브쿼리가 사용된 경우 - IN(select .. from .. )

상수일 때는 매우 빠르게 쿼리가 처리된다.
Mysql 8.0 이전 버전에서는 풀 테이블 스캔을 했던 경우 (튜플 사용)
where (dept_no, emp_no) IN (('d001',10017),('d002',10144),('d003',10054));
8.0부터는 튜플 그대로 사용해도 인덱스를 최적으로 사용할 수 있게 개선됐다.

IN (subquery)는 8.0전까지는 최적화가 불안했고, 8.0부터는 IN (subquery)와 같은 세미 조인의 최적화가 많이 안정화됐다.

NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문이다.
* NOT IN 연산자가 프라이머리 키와 비교될 때 가끔 쿼리의 실행 계획에 인덱스 레인지 스캔이 표시되는 경우가 있다. 하지만 이는 InnoDB 테이블에서 프라이머리
키가 클러스터링 키이기 때문일 뿐 실제 IN과 같이 효율적으로 실행된다는 것을 의미하지는 않는다.

Mysql 내장함수

IFNULL(NULL, 1) NULL이면 1반환

ISNULL(0) NULL 인지 아닌지 

NOW()

**SYSDATE() : SLEEP(2)와 같이 사용됐을 때 영향을 받는다. 
SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못한다. 
ex) WHERE emp_no=10001 AND from_date>SYSDATE(); 의 경우 <pk는 emp_no, from_date> emp_no만 index를 사용한다. SYSDATE로 인하여 사용하지 못한다.

이미 sysdate() 함수를 사용하고 있다면 Mysql 서버의 설정파일에 sysdate-is-now 시스템 변수를 넣어서 활성화하는 것이 이 같은 문제점을 제거하는
빠른 해결책이다. 

DATE_FORMAT(NOW(), '%Y-%m-%d')

STR_TO_DATE(NOW(), '%Y-%m-%d')
문자열을 DATETIME 타입으로 변환할 때 사용

DATE_ADD(NOW(), INTERVAL 1 DAY)
DATE_SUB(NOW(), INTERVAL 1 DAY)
DAY자리에 대신 사용할 수 있는 단위 
YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MICROSECOND, QUARTER(분기), WEEK

UNIX_TIMESTAMP()
'1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수
인자가 없을 경우 현재 날짜, 시간의 타임스탬프 값을 전달

FROM_UNIXTIME()
인자로 전달한 타임스탬프 값을 DATETIME 타입으로 변환하는 함수다.

TIMESTAMP 타입은 4바이트 숫자 타입으로 저장되기 때문에 '1970-01-01 00:00:01' ~ '2038-01-09 03:14:07' 까지의 날짜 값만 가능하다.

RPAD LPAD
문자열의 좌측, 우측 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수. 
ex) RPAD('Cloee', 10, '_') -> Cloee_____
    LPAD('123',6,'0') -> 000123

RTRIM LTRIM TRIM
문자열의 좌측, 우측에 연속된 공백문자(space, newline, tab)를 제거하는 함수. TRIM은 양쪽 다 수행한다.

CONCAT
여러 개의 문자열을 연결해서 하나의 문자열로 반환하는 함수, 인자 개수 제한이 없다. CAST() 함수를 이용해 숫자를 문자열로 변환하여 사용하는 편이 안전하다.
ex) CONCAT('A','B',CAST(1 AS CHAR)) -> AB1

CONCAT_WS(',','A','B') -> A,B (첫 인자의 구분자가 들어간다)

GROUP BY 문자열 결합(GROUP_CONCAT) 
그룹 함수 중 하나이다. 주로 GROUP BY와 함께 사용하며, GROUP BY가 없는 SQL에서 사용하면 단 하나의 결괏값만 만들어낸다. 
값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하며, 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하다.
ex)
SELECT GROUP_CONCAT(dept_no) FROM departments;
-> d009,d005,d002 ...
SELECT GROUP_CONCAT(dept_no SEPARATOR '|') FROM departments;
-> d009|d005|d002 ...
SELECT GROUP_CONCAT(dept_no ORDER BY emp_no DESC) FROM departments; // 정렬 후 연결(함수 내에서 정의된 ORDER BY는 쿼리 전체적으로 설정값과 무관하다)
SELECT GROUP_CONCAT(DISTINCT dept_no ORDER BY emp_no DESC) FROM departments; // 중복 제거 및 정렬 후 연결

GROUP_CONCAT() 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용한다. 
지정된 크기를 초과할 경우 경고 메시지가 발생하며 GUI 도구(TOAD, SQLyog)를 이용할 경우 단순히 경고만 발생하고, JDBC로 실행할 경우에는 ERROR로 취급되어
쿼리를 실패하기에 GROUP_CONCAT()의 결과가 지정된 버퍼 크기를 초과하지 않게 주의해야 한다.
group_concat_max_len 시스템 변수로 메모리 버퍼의 크기를 조정할 수 있다. default는 1KB이다.
8.0부터는 용도에 맞게 래터럴 조인이나 윈도우 함수를 이용할 수 있다. (p34)

CASE WHEN THEN END (SWITCH와 비슷한 용도)

CAST,CONVERT 
PrePared Statement를 제외하면 SQL은 텍스트 기반으로 작동하기 때문에 SQL에 포함된 모든 입력값은 문자열처럼 취급된다. 명시적으로 타입의 변환이 필요할 때
CAST()를 사용하면 되며, CONVER() 도 거의 비슷하며 함수의 인자 사용 규칙만 조금 다르다.
CAST() - DATE, TIME, DATETIME, BINARY, CHAR, DECIMAL, SIGNED INTEGER, UNSIGNED INTEGER
ex) CAST('1234' AS SIGNED INTEGER)
CONVERT()
1) 타입을 변환하는 용도 ex) CONVERT(1-2, UNSIGNED)
2) 문자열의 문자 집합을 변환하는 용도 ex) CONVERT('ABC' USING 'utf8mb4')

이진값과 16진수 문자열 변환 
HEX() 함수는 이진값을 사람이 읽을 수 있는 형태의 16진수의 문자열(HEX String)로 변환하는 함수
UNHEX() 함수는 16진수의 문자열을 읽어서 이진값으로 변환하는 함수다. 이진값 = 바이너리 값

암호화 및 해시 함수
MD5와 SHA 모두 비대칭형 암호화 알고리즘인데, 인자로 전달한 문자열을 각각 지정된 비트 수의 해시 값을 만들어내는 함수다.
SHA() - SHA-1 암호화 알고리즘을 사용하며, 결과로 160비트(20바이트) 해시 값을 반환한다.
SHA2() - SHA 암호화 알고리즘보다 더 강력한 224비트부터 512비트 암호화 알고리즘을 사용해 생성된 해시 값을 반환한다.
MD5() - 메시지 다이제스트 알고리즘을 사용해 128비트 해시 값을 반환한다.

함수들 모두 사용자의 비밀번호와 같은 암호화가 필요한 정보를 인코딩하는 데 사용되며, 특히 MD5() 함수는 말그대로 입력된 문자열의 길이를 줄이는(Digest) 용도로도
사용된다. SHA, MD5 두 함수의 출력 값은 16진수 문자열 형태이기 떄문에 저장하려면 저장 공간이 각각 20바이트와 16바이트의 두 배로 필요하다. 
그리고 SHA2 함수는 사용된 인자 값에 따라 출력되는 해시 값의 길이가 달라지므로 사용된 이자의 두 배가 필요하다. 
그래서 암호화된 값을 저장해 두기 위해 
MD5() - CHAR(32)
SHA() - CHAR(40) 의 타입을 필요로 한다.
저장공간을 원래의 16바이트, 20바이트로 줄이고 싶다면 CHAR, VARCHAR가 아닌 BINARY, VARBINARY 형태의 타입에 저장하면 된다.
이 때는 칼럼의 타입을 BINARY(16) or (20)으로 정의하고 MD5(), SHA() 함수의 결과를 UNHEX() 함수를 이용해 이진값으로 변환해서 저장하면 된다.
BINARY 타입에 저장된 이진값을 사람이 읽을 수 있는 16진수 문자열로 다시 되돌릴 떄는 HEX() 함수를 사용하면 된다. 예제 (p40)

MD5() 함수나 SHA(), SHA2() 함수는 모두 비대칭형 암호화 알고리즘이다. 이 함수들의 결괏값은 중복 가능성이 매우 낮기 때문에 길이가 긴 데이터를 크기를 줄여서
인덱싱(해시)하는 용도로도 사용된다. 예를들어, URL 같은 값은 1KB를 넘을 떄도 있으며 전체적으로 값의 길이가 긴 편이다. 이러한 데이터를 검색하려면 인덱스가 
필요하지만 긴 칼럼에 대해 전체 값으로 인덱스를 생성하는 것은 불가능 할뿐만아니라 공간 낭비도 커진다. 
**URL의 값을 MD5() 함수로 단축하면 16바이트로 저장할 수 있고, 이 16바이트로 인덱스를 생성하면 되기 때문에 상대적으로 효율적이다.

Mysql 8.0 부터는 함수 기반의 인덱스를 생성하면 별도 칼럼을 추가하지 않아도 된다. 해시 칼럼 적용 예제(p41,42) INDEX ix_accessurl ( (MD5(access_url)) )
저장공간을 더 줄이고자 하면 UNHEX() 함수를 사용해 이진값으로 만들면 된다. 131byte -> 67byte

처리 대기(SLEEP)
SQL의 개발이나 디버깅 용도로 잠깐 대기하거나 일부러 쿼리의 실행을 오랜 시간 유지하고자 할 때 상당히 유용한 하뭇다.
초 단위로 인자를 받으며, 지정 시간 만큼만 대기한다. ex) SELECT SLEEP(1.5) FROM employees ; -> 결과가 10건이라면 * 1.5로 15초동안 대기하게 된다.

벤치 마크(BENCHMARK)
디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수다. 
ex) SELECT BENCHMARK(10000, MD5('abcdef')); -> 반복할 횟수, 반복할 표현식(1개의 결과값을 반환하는 표현식)
하지만 반복실행에서의 맹점은 쿼리 파싱, 최적화, 테이블 잠금, 네트워크 비용 등이 1번만 소용된다는 점이다.
해당 함수로 얻은 쿼리나 함수의 성능은 그 자체로는 큰 의미가 없으며, 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장한다.

IP 주소 변환(INET_ATON, INET_NTOA)
IP 주소는 4바이트의 Unsigned Integer이다. 하지만 대부분의 DBMS에서는 IP정보를 VARCHAR(15)에 '.'으로 구분해서 저장한다. 
이렇게 문자열로 저장된 IP주소는 저장 공간을 훨씬 많이 필요로 한다. 그리고 A,B,C의 클래스로 구분하는 것도 불가능하다. 
INET_ATON, INET_NTOA은 IPv4 주소를 문자열이 아닌 부호 없는 정수 타입에 저장할 수 있게 제공한다. 
ATON은 문자열 -> 정수형 NTOA는 정수형 -> 문자열로 변환하는 함수다.
IPv6는 INET6_ATON, INET6_NTOA으로 변환할 수 있으며, IPv4, IPv6 주소를 HEX,UNHEX()를 사용하여 바이너리로의 변환이 가능하다. 
IPv4를 위해서는 VARBINARY(4) IPv6를 위해서는 VARBINARY(16)을 사용하면 된다.

JSON 포맷(JSON_PRETTY)
단순 텍스트 포맷을 JSON_PRETTY()를 통해 읽기 쉬운 포맷으로 변환해준다.

JSON 필드 크기(JSON_STORAGE_SIZE)
JSON 데이터는 텍스트 기반이지만 Mysql 서버는 디스크의 저장 공간을 절약하기 위해 JSON 데이터를 실제 디스크에 저장할 때 BSON(Binary JSON) 포맷을 사용한다.
하지만 BSON으로 변환 됐을 때 저장 공간의 크기 예측하기 어렵고, 그 해결책으로 JSON_STORAGE_SIZE() 함수를 제공한다. 반환 단위는 Byte이다.


JSON 필드 추출(JSON_EXTRACT)
첫 번째 인자는 JSON 데이터가 저장된 칼럼 또는 JSON 도큐먼트 자체이며, 
두 번째 인자는 가져오고자 하는 필드의 JSON 경로를 명시한다.

SELECT emp_no, JSON_EXTRACT(doc, "$.first_name") FROM employees_docs;
SELECT emp_no, JSON_UNQUOTE(JSON_EXTRACT(doc, "$.first_name")) FROM employees_docs; -> ""없이 가져올 수 있음 

해당 위의 함수는 JSON 처리의 아주 기본적인 처리이기 때문에 사용자의 편의성을 위해 JSON 연산자를 제공한다.
SELECT emp_no, doc->"$.first_name" FROM employee_docs;
SELECT emp_no, doc->>"$.first_name" FROM employee_docs; -> ""없이 가져올 수 있음

JSON 오브젝트 포함 여부 확인(JSON_CONTAINS)
JSON 도큐먼트 또는 지정된 JSON 경로에 JSON 필드를 가지고 있는지를 확인하는 함수다. 
ex) 1) SELECT emp_no FROM employee_docs WHERE JSON_CONTAINS(doc, '{"first_name":"Christian"}'); 
    2) SELECT emp_no FROM employee_docs WHERE JSON_CONTAINS(doc, '"Christian"', '$.first_name');
첫번째 인자 - 저장하고 있는 칼럼이나 JSON 도큐먼트
두번째 인자 - JSON 오브젝트(도큐먼트 또는 필드 값)
세번째 인자(선택) - JSON 경로

JSON 오브젝트 생성(JSON_OBJECT)
SELECT JSON_OBJECT("empNo", emp_no, "salary", salary, "fromDate", from_date,"toDAte", to_date) AS as_json FROM salaries LIMIT 3;

JSON 칼럼으로 집계(JSON_OBJECTAGG & JSON_ARRAYAGG) - JSON_OBJECTAGG. 키 값, JSON_ARRAYAGG. 배열
GROUP BY 절과 함께 사용되는 집계 함수로서 RDBMS 칼럼의 값들을 모아 JSON 배열 또는 도큐먼트를 생성하는 함수다. 예제(p50)

JSON 데이터를 테이블로 변환(JSON_TABLE)
반환하는 테이블의 레코드 건수는 원본 테이블(JSON_TABLE() 함수 직전에 명시된 테이블)과 동일한 레코드 건수를 가진다.
from JSON_TABLE(doc,"$" COLUMNS (emp_no INT PATH "$.emp_no",
                                 gender CHAR(1) PATH "$.gender", 
                                 first_name VARCHAR(20) PATH "$.first_name") as e
JSON_TABLE() 함수는 항상 내부 임시 테이블을 이용하기 때문에 임시 테이블에 레코드가 많이 저장되지 않게 주의 해야 한다.

SELECT

SELECT 절의 처리 순서
이 책에서 SELECT 문장이라고 하면 SQL 전체를 의미한다. 그리고 SELECT 키워드와 실제 가져올 칼럼을 명시한 부분만 언급할 때는 SELECT 절이라고 표현한다.

알고 있는 순서 FROM WHERE GROUP BY HAVING SELECT ORDER BY

각 쿼리 절의 실행 순서 - 테이블들의 WHERE 적용 및 조인 실행 -> GROUP BY -> DISTINCT -> HAVING -> ORDER BY -> LIMIT (p54, 그림11.3)
이 순서가 바뀌어서 실행되는 형태의 쿼리는 거의 없다. 또한 ORDER BY, GROUP BY절이 있더라도 인덱스를 이용해 처리할 때는 단계 자체가 불필요하여 생략된다.

각 쿼리 절의 실행 순서(예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우)
드라이빙 테이블(WHERE 적용) -> ORDER BY -> 드리븐 테이블(1,2) 조인 실행 -> LIMIT (p54, 그림11.4)
-> 이 경우는 첫 번째 테이블만 읽어서 정렬을 수행한 뒤에 나머지 테이블을 읽는데, 주로 GROUP BY 절이 없이 ORDER BY만 사용된 쿼리에서 사용될 수 있다.

해당 순서를 벗어나는 쿼리가 필요하다면 인라인 뷰를 사용해야 한다. -> 임시 테이블이 사용되기 때문에 주의해야 한다 (10.3.2.8절)

Mysql의 LIMIT은 오라클의 ROWNUM과 조금 성격이 달라서 WHERE 조건으로 사용하지 않고 항상 모든 처리의 결과에 대해 레코드 건수를 제한하는 형태로 사용한다.

여기에 표시되지는 않았지만 Mysql 8.0에 새로 도입된 WITH 절(CTE)은 항상 제일 먼저 실행되어 임시 테이블로 저장된다.
그리고 WITH절로 만들어진 임시 테이블은 위의 순서에서 단독으로 조회되거나 조인되는 테이블로 활용된다.
또한 8.0에서 새로 추가된 윈도우 함수에서도 쿼리의 각 절이 실행되는 순서가 중요한데. 차후에 작성하겠다.

WHERE 절과 GROUP BY 절, ORDER BY절의 인덱스 사용

인덱스를 사용하기 위한 기본 규칙
기본적으로 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다. 
인덱스는 칼럼의 값을 아무런 변환 없이 B-Tree에 정렬해서 저장한다. WHERE 조건이나 GROUP BY, ORDER BY에서도 원본값을 검색하거나 정렬할 때만 B-Tree에 
정렬된 인덱스를 이용한다.

추가로 WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야 한다. 해당 내용은 위의 조건에 같은 범주에 속하긴 한다.
ex) INTEGER의 2 VARCHAR의 '2' 처럼 다를 경우에 타입이 자동변환되서 비교 되기에 인덱스 풀 스캔을 실행하게 된다.

WHERE 절의 인덱스 사용
WHERE 조건이 인덱스를 사용하는 방법은 크게 작업 범위 결정 조건과 체크 조건의 두 가지 방식으로 구분할 수 있다.
두 방식 중 작업 범위 결정 조건은 WHERE 절에서 동등 비교 조건이나 IN으로 구성된 조건에 사용된 칼럼들이 인덱스의 칼럼 구성과 좌측에서부터 비교했을 때
얼마나 일치하는가에 따라 달라진다.
ex) 인덱스 칼럼 순서 COL_1, COL_2, COL_3, COL_4
WHERE 조건절 칼럼 순서 COL_2=? COL_4=? COL_3>? COL_1=?
위의 경우 인덱스는 COL_1, COL_2까지만 사용가능하다. 이유는 인덱스의 순서가 순서대로 되어 있지 않아서가 아니라 COL_3이 동등 비교가 아닌 범위 비교 조건으로
사용되어 COL_4는 체크 조건으로 사용되기 때문이다.
* WHERE 절에서는 칼럼의 순서가 중요하지 않다.

8.0 부터는 인덱스를 구성하는 칼럼별로 오름차순, 내림차순 정렬을 혼합해서 생성할 수 있게 개선됐다.

SELECT *
  FROM employees
 WHERE first_name='Kebin' OR last_name='Poly';
위의 쿼리와 같이 OR 연산자를 사용하면 처리 방법이 완전히 바뀐다.

first_name은 index가 있고 last_name은 index가 없는 경우 AND로 연결됐다면 first_name의 인덱스를 이용하지만, OR 연결되었기에 풀 테이블 스캔을 하게 된다.
만약 각각 index가 있다면 index_merge 접근 방법으로 실행할 수 있다.

GROUP BY 절의 인덱스 사용
GROUP BY절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 순서와 같으면 GROUP BY 절은 일단 인덱스를 이용할 수 있다.
예외) WHERE 조건절에 인덱스를 구성하는 칼럼이 동등 비교 조건으로 사용된다면 해당 칼럼이 빠져도 인덱스를 이용한 GROUP BY가 가능할 때도 있다.
인덱스 (COL_1, COL_2, COL_3, COL_4) 일 때
WHERE COL_1='상수' ... GROUP BY COL_2, COL_3
COL_1은 상숫값과 비교되므로 GROUP BY COL_1, COL_2, COL_3과 같은 결과를 만들어 낸다.

ORDER BY 절의 인덱스 사용
ORDER BY는 GROUP BY와 상당히 비슷하며, 요건도 거의 흡사하다. 하지만 조건이 하나 더 있는데, 정렬되는 각 칼럼의 오름차순, 내림차순 옵션이 인덱스와
같거나 정반대인 경우에만 사용할 수 있다는 것이다.
Mysql의 인덱스는 모든 칼럼이 오름차순으로만 정렬돼 있기 때문에 ORDER BY 절의 모든 칼럼이 오름차순이거나 내림차순일 때만 인덱스를 사용할 수 있다.

WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 사용
SQL 문장이 WHERE 절과 ORDER BY 절을 가지고 있다고 가정했을 때 WHERE 조건은 A인덱스를 사용하고 ORDER BY는 B인덱스를 사용하도록 쿼리가 실행될 수는 없다.
GROUP BY 또한 마찬가지이다.
WHERE, ORDER BY절이 같이 사용된 하나의 쿼리 문장은 다음 3가지 중 한 가지 방법으로만 인덱스를 이용한다..
1) WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용
2) WHERE 절만 인덱스를 이용 (별도의 정렬 처리 방식, Using Filesort)
3) ORDER BY 절만 인덱스를 이용 - WHERE 절은 인덱스를 이용하지 못할 때, 이 방식은 ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건씩 WHERE 절의
조건에 일치하는지 비교하고, 일치하지 않을 때는 버리는 형태로 처리한다. 주로 아주 많은 레코드를 조회해서 정렬해야 할 때는 이런 형태로 튜닝하기도 한다.
**(설명의 이해도를 위해 인덱스 스킵 스캔은 배제한 내용)

동등조건 외에 범위 조건의 비교가 사용되는 쿼리
WHERE COL_1 > 10 ORDER BY COL_1, COL_2, COL_3 // WHERE, ORDER BY 인덱스 사용가능
WHERE COL_1 > 10 ORDER BY COL_2, COL_3 // WHERE 만 인덱스 사용가능

GROUP BY 절과 ORDER BY 절의 인덱스 사용
GROUP BY와 ORDER BY절이 동시에 사용된 쿼리에서 두 절이 모두 하나의 인덱스를 사용해서 처리되려면 GROUP BY 절에 명시된 칼럼과 ORDER BY에 명시된 칼럼의 순서와
내용이 모두 같아야 한다. 두 절이 같이 사용된 쿼리에서는 둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘 다 인덱스를 사용하지 못한다. 

*5.7까지는 GROUP BY는 GROUP BY 칼럼에 대한 정렬까지 함께 수행하는 것이 기본 작동 방식이었다. 하지만 8.0부터는 GROUP BY 절이 칼럼의 정렬까지는 보장하지
않는 형태로 바뀌었다. 그래서 8.0부터는 GROUP BY 칼럼으로 그루핑과 정렬을 모두 수행하기 위해서는 ORDER BY도 명시해야 한다.

WHERE 절의 비교 조건 사용 시 주의사항
NULL 비교
다른 DBMS와는 조금 다르게 Mysql에서는 NULL 값이 포함된 레코드도 인덱스로 관리된다. 이는 인덱스에서는 NULL을 하나의 값으로 인정해서 관리한다는것을 의미한다.
SQL 표준에서 NULL의 정의는 비교할 수 없는 값이다. 그래서 두 값이 모두 NULL을 가진다고 하더라도 이 두 값이 동등한지 비교하는 것은 불가능하다.
연산이나 비교에서 한쪽이라도 NULL이면 그 결과도 NULL이 반환되는 이유가 바로 여기에 있다. NULL을 비교하려면 IS NULL (또는 <=>)을 사용해야 하고,
그 밖의 방법으로는 칼럼의 값이 NULL인지 알 수 있는 방법이 없다.

ISNULL() 함수를 WHERE 조건에서 사용할 때의 주의점
SELECT * FROM titles WHERE to_date IS NULL;
SELECT * FROM titles WHERE ISNULL(to_date);
SELECT * FROM titles WHERE ISNULL(to_date)=1;
SELECT * FROM titles WHERE ISNULL(to_date)=true;
=> 1,2번째 쿼리는 인덱스를 사용할 수 있고(to_date 관련), 3,4번째 쿼리는 인덱스나 테이블을 풀 스캔하는 형태로 처리된다.
NULL을 비교 할 때는 가급적 IS NULL 연산자를 사용하길 권장한다.

문자열이나 숫자 비교
문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용할 것을 권장한다.

날짜 비교
DATE 또는 DATETIME과 문자열 비교
DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행한다.
비교하는 칼럼의 타입이 DATE 또는 DATETIME이면 별도로 문자열을 DATE 또는 DATETIME타입으로 명시적으로 변환하지 않아도 Mysql이 내부적으로 변환을 수행한다.
ex) SELECT COUNT(*) FROM employees WHERE hire_date>'2011-07-23';
하지만 칼럼을 강제적으로 문자열로 바꿀경우에는 인덱스를 효율적으로 이용하지 못한다. 칼럼을 변경하지 않고 상수를 변경하는 형태로 조건을 사용하는 것이 좋다.
DATE_ADD, DATE_SUB도 마찬가지이다.

DATE, DATETIME의 비교
ex) STR_TO_DATE('2011-06-30','%Y-%m-%d') < STR_TO_DATE('2011-06-30 00:00:01','%Y-%m-%d %H:%i:%s') -> TRUE(1)
STR_TO_DATE('2011-06-30','%Y-%m-%d') == '2011-06-30 00:00:00' 으로 변환되어 비교 됨.

DATETIME과 TIMESTAMP의 비교
DATE나 DATETIME 타입의 값과 TIMESTAMP의 값을 별도의 타입 변환 없이 비교하면 문제없이 작동하고 실제 실행 계획도 인덱스 레인지 스캔을 사용해서 동작하는
것처럼 보이지만 사실은 그렇지 않다.
UNIX_TIMESTAMP() 함수의 결괏값은 Mysql 내부적으로는 단순 숫자 값에 불과할 뿐이다. 반드시 비교 값으로 사용되는 상수 리터럴을 비교 대상 칼럼의 타입에
맞게 변환해서 사용하는 것이 좋다. 칼럼이 DATETIME 타입이라면 FROM_UNIXTIME() 함수를 이용해 TIMESTAMP 값을 DATETIME타입으로 만들어서 비교해야 한다.
반대로 칼럼의 타입이 TIMESTAMP라면 UNIX_STAMP() 함수를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교해야 한다. 또는 간단하게 NOW() 함수를 이용해도 된다.

Short-Circuit Evaluation (in_transaction p72 예제)
여러 개의 표현식이 AND 또는 OR 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화를 Short-Circuit Evaluation
(p 72)
1번 조건의 결과 20000건
2번 조건의 결과 0건      // 1,2번은 인덱스를 사용할 수 없는 조건이라는 전제
1,2번 조건을 결합(AND) 했을 때 1,2번의 조건을 순서를 바꾼다면 ? 2번 조건이 먼저 나열됐을 경우가 응답 시간이 더 짧아지고 1번의 결과가 더 클 경우 결과도
더 크게 차이 난다.

Mysql 서버는 쿼리의 WHERE 절에 나열된 조건을 순서대로 "Short-circuit Evaluation" 방식으로 평가해서 해당 레코드를 반환해야 할지 말지를 결정한다.
그런데 WHERE 절의 조건 중에서 인덱스를 사용할 수 있는 조건이 있다면 "Short-circuit Evaluation"과는 무관하게 Mysql 서버는 그 조건을 가장 최우선으로
사용한다. 그래서 WHERE 조건절에 나열된 조건의 순서가 인덱스의 사용 여부를 결정하지는 않는다.

Mysql 서버에서 쿼리를 작성할 때 가능하면 복잡한 연산 또는 다른 테이블의 레코드를 읽어야 하는 서브쿼리 조건 등은 WHERE 절의 뒤쪽으로 배치하는 것이
성능상 도움이 될 것이다. 물론 WHERE 조건 중에서 인덱스를 사용할 수 있는 조건은 WHERE 절의 어느 위치에 나열되든지 그 순서에 관계없이 가장 먼저 
평가되기 때문에 고려하지 않아도 된다.

DISTINCT
여러 테이블을 조인하는 쿼라에서는 조인 조건에 따라서 레코드가 몇 배씩 불어나기도 하는데, 각 테이블 간의 업무적인 연결 조건을 이해하지 못하고 쿼리를
작성하는 경우 주로 이렇게 DISTINCT를 남용하는 경우가 발생한다. 테이블 간 1:1, 1:M 조인인지 업무적 특성을 잘 이해하는게 중요하다.

LIMIT n
ex) SELECT * FROM employees
     WHERE emp_no BETWEEN 10001 AND 10010
     ORDER BY first_name
     LIMIT 0, 5;
-> 1. employees 테이블에서 WHERE 절의 검색 조건에 일치하는 레코드를 전부 읽어 온다.
   2. 1번에서 읽어온 레코드를 first_name 칼럼값에 따라 정렬한다.
   3. 정렬된 결과에서 상위 5건만 사용자에게 반환한다.
Mysql의 LIMIT은 WHERE 조건이 아니기에 항상 쿼리의 가장 마지막에 실행된다.
LIMIT의 중요한 특성은 LIMIT에서 필요한 레코드 건수만 준비되면 즉시 쿼리를 종료한다는 것이다. 즉, 위의 쿼리에서 모든 레코드의 정렬이 완료되지 않았다고
하더라도 상위 5건까지만 정렬되면 작업을 멈춘다.

1) GROUP BY 후에 LIMIT이 들어올 경우 LIMIT이 있다고 하더라도 GROUP BY가 끝난 후에 적용이 된다.
2) DISTINCT는 정렬에 대한 요건이 없어 유니크한 그룹만 만들어 내면 된다. 해당 처리를 하다가 유니크한 레코드가 LIMIT 건수만큼 채워지면 그 순간 쿼리를 멈춘다.
   DISTINCT와 함께 사용된 LIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 한다.
하지만 ORDER BY, GROUP BY, DISTINCT가 인덱스를 이용해 처리될 수 있다면 LIMIT 절은 꼭 필요한 만큼의 레코드만 읽게 만들어 쿼리의 작업량을 상당히 줄여준다.
2개 인자 -> LIMIT(시작위치, 개수) (0부터 시작한다) LIMIT (10,10) 11번째 부터 10개

LIMIT 제한 사항 - LIMIT의 인자로 표현식이나 별도의 서브쿼리를 사용할 수 없다. ex) LIMIT (100-10) syntax error

limit n,m -> limit 200000, 10 쿼리 실행이 느리다.

COUNT()
*은 모든 칼럼을 의미하는 게 아니라 그냥 레코드 자체를 의미한다.
InnoDB 스토리지 엔진을 사용하는 테이블에서는 WHERE 조건이 있는 COUNT(*)라 하더라도 직접 데이터나 인덱스를 읽어야만 레코드 건수를 가져올 수 있기 때문에
큰 테이블에서 COUNT() 함수를 사용하는 작업은 주의해야 한다.
만약 대략적인 레코드 건수로 충분하다면 SHOW TABLE STATUS 명령으로 통계 정보를 참조하는 것도 좋은 방법이다.
SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_ROWS, (DATA_LENGTH+INDEX_LENGTH)/1024/1024/1024 AS TABLE_SIZE_GB
  FROM information_schema.TABLES
 WHERE TABLE_SCHEMA='employees'
   AND TABLE_NAME='employees';
   
COUNT(*) 쿼리에서 가장 많이하는 실수는 ORDER BY 구문이나 LEFT JOIN과 같은 레코드 건수를 가져오는 것과는 무관한 작업을 포함하는 것이다.
대부분 COUNT(*) 쿼리는 페이징 처리를 위해 사용할 때가 많은데, 많은 개발자가 SELECT 쿼리를 그대로 복사해서 칼럼이 명시된 부분만 삭제하고 그 부분을 COUNT(*)
함수로 대체해서 사용하곤 한다. 그래서 단순히 COUNT(*)만 실행하는 쿼리임에도 ORDER BY가 포함돼 있다거나 별도의 체크 조건을 가지지도 않는 LEFT JOIN이
사용된 채로 실행될 때가 많다. COUNT(*) 쿼리에서 ORDER BY 절은 어떤 경우에도 필요치 않다. 그리고 LEFT JOIN 또한 레코드 건수의 변화가 없거나
아우터 테이블에서 별도의 체크를 하지 않아도 되는 경우에는 모두 제거하는 것이 성능상 좋다. (8.0 부터는 옵티마이저가 ORDER BY를 무시한다)

** 인덱스를 제대로 사용하도록 튜닝되지 못한 COUNT(*) 쿼리는 페이징해서 데이터를 가져오는 쿼리보다 몇 배 또는 몇십 배 느리게 실행될 수도 있다.

JOIN
JOIN의 순서와 인덱스
인덱스 레인지 스캔은 인덱스를 탐색하는 단계와 인덱스를 스캔하는 과정으로 구분해 볼 수 있다.
일반적으로 인덱스를 이용해서 쿼리하는 작업에서는 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 
인덱스 탐색 작업은 상대적으로 부하가 높은 편이다. 

조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 실행하면 된다. 하지만 드리븐 테이블에서는
인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다. 드라이빙, 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을
읽는 것이 훨씬 더 큰 부하를 차지한다. 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

예제)
SELECT *
  FROM employees e, dept_emp de
 WHERE e.emp_no=de.emp_no;
 
 ** 드라이빙 테이블 한번 읽고 드리븐 테이블은 드라이빙 테이블에서 읽은 레코드 건수만큼 반복해서 읽음 **
 ** PK가 있는 쪽이 드리븐(뒤로)테이블, FK가 있는 쪽이 드라이빙(앞으로)테이블로 선정해야 한다. ** 
 ** 작업 대상이 되는 행(rows)의 수가 적은 테이블부터 액세스 되어야 전체 탐색이 줄어든다. ** 

이 두 테이블의 조인 쿼리에서 각각의 emp_no 칼럼에 인덱스가 있을 때와 없을 때 조인 순서 어떻게 달라지는지 ?
1) 두 칼럼 모두 각각 인덱스가 있는 경우
어느 테이블을 드라이빙으로 선택하든 인덱스를 이용해 드리븐 테이블의 검색 작업을 빠르게 처리할 수 있다. 이럴 때 옵티마이저가 통계 정보를 이용해 적절히
드라이빙 테이블을 선택하게 된다. 각 테이블의 통계 정보에 있는 레코드 건수에 따라 employees가 드라이빙 테이블이 될 수도 있고, dept_emp 테이블이
드라이빙 테이블로 선택될 수도 있다. 보토으이 경우 어느 쪽 테이블이 드라이빙 테이블이 되든 옵티마이저가 선택하는 방법이 최적일 때가 많다.

2) employees.emp_no에만 인덱스가 있는 경우
dept_emp 테이블이 드리븐 테이블로 선택된다면 employees 테이블의 레코드 건수만큼 dept_emp 테이블을 풀스캔해야 하기에 옵티마이저는 
항상 dept_emp 테이블을 드라이빙 테이블로 선택해야 한다. 이 때 e.emp_no=10001 같은 employees 테이블을 아주 효율적으로 접근할 수 있는 조건이 있더라도
옵티마이저는 employees 테이블을 드라이빙 테이블로 선택하지 않을 가능성이 높다.

3) dept_emp.emp_no에만 인덱스가 있는 경우
employees와 반대로 dept_emp 테이블을 드리븐 테이블로 조인을 수행하게 실행 계획을 수립한다.

4) 두 칼럼 모두 인덱스가 없는 경우
어느 테이블을 드라이빙으로 선택하더라도 드리븐 테이블의 풀 스캔은 발생하기 때문에 옵티마이저가 적절히 드라이빙 테이블을 선택한다.
단 레코드 건수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 훨씬 효율적이다. 이렇게 적절한 인덱스가 없는경우 8.0.18 이전에는 블록 네스티드 루프 조인을
사용했다. 하지만 이후 부터는 블록 네스티드 루프 조인이 없어지고 해시 조인이 도입되면서 해시 조인으로 처리된다. 

JOIN 칼럼의 데이터 타입
WHERE 절의 칼럼의 데이터 타입과 동일하다. 테이블 조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없다.

인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR, VARCHAR // INT, BIGINT, SMALLINT // DATE, DATETIME 타입 사이에서는 발생하지 않는다.
하지만 대표적으로 다음의 비교 패턴은 문제가 될 가능성이 높다.

1) CHAR 타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우
2) 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 다른 경우 (COLLATE utf8bm4_general_ci, COLLATE latin1_general_ci)
3) 같은 INT 타입이더라도 부호(Sign)의 존재 여부가 다른 경우

OUTER JOIN의 성능과 주의사항
이너 조인은 조인 대상 테이블에 모두 존재하는 레코드만 결과 집합으로 반환한다. 이너 조인의 이 같은 특성 때문에 아우터 조인으로만 조인을 실행하는
쿼리들도 자주 보인다. 

테이블의 데이터가 일관되지 않은 경우에만 아우터 조인이 필요한 경우이다.
ex) employees 테이블에 존재하는 사원 중에서 dept_emp 테이블에 레코드를 갖지 않는 경우 (아우터 조인을 할 필요가 없다)
Mysql 옵티마이저는 절대 아우터로 조인되는 테이블을 드라이빙 테이블로 선택하지 못하기 때문에 풀 스캔이 필요한 employees 테이블을 드라이빙 테이블로 선택한다.
그 결과 쿼리의 성능이 떨어지는 실행 계획을 수립한 것이다.

아우터 조인 쿼리를 작성하면서 많이 하는 또 다른 실수는 아우터로 조인되는 테이블에 대한 조건을 WHERE 절에 함께 명시하는 것이다.
ex) SELECT *
      FROM employees e
      LEFT JOIN dept_manager mgr ON mgr.emp_no =e.emp_no
     WHERE mgr.dept_no='d001';
위의 LEFT JOIN이 사용된 쿼리는 WHERE 절의 조건 때문에 Mysql 옵티마이저가 LEFT JOIN을 INNER JOIN으로 변환해서 실행해버린다.
정상적으로 아우터 조인이 되게 만들려면 WHERE 절을 LEFT JOIN ON 절로 옮겨야 한다.

예외적으로 OUTER JOIN으로 연결되는 테이블의 칼럼에 대한 조건을 WHERE 절에 사용해야 하는 경우가 있는데, 다음과 같이 안티 조인 효과를 기대하는 경우이다.
ex) SELECT *
      FROM employees e
      LEFT JOIN dept_manager dm ON dm.emp_no=e.emp_no
     WHERE dm.emp_no IS NULL
     LIMIT 10;
위 쿼리는 사원 중에서 매니저가 아닌 사용자들만 조회하는 쿼리인데, WHERE 절에 아우터로 조인된 dept_manager 테이블의 emp_no 칼럼이 NULL인 레코드들만
조회한다. 이런 형태의 요건이 아우터 테이블의 칼럼이 WHERE절에 사용될 수 있는 유일한 경우다. 그 외의 경우 Mysql 서버는 LEFT JOIN을 INNER 자동변환한다. ***

JOIN과 외래키
외래키는 조인과 아무런 연관리 없다. 외래키를 생성하는 주목적은 데이터의 무결성을 보장하기 위해서다. 외래키와 연관된 무결성을 참조 무결성이라고 표현한다.
데이터 모델링을 할 때는 각 테이블 간의 관계를 필수적으로 그려 넣어야 한다. 하지만 그 데이터 모델을 데이터베이스에 생성할 때는 그 테이블 간의 관계는 외래키로
생성하지 않을 때가 더 많다. 

지연된 조인
조인을 사용해서 데이터를 조회하는 쿼리에 GROUP BY, ORDER BY를 사용할 때 각 처리 방법에서 인덱스를 사용한다면 이미 최적으로 처리되고 있을 가능성이 높다.
하지만 그렇지 못하다면 Mysql 서버는 우선 모든 조인을 실행하고 난 다음 GROUP BY나 ORDER BY를 처리할 것이다.
지연된 조인이란 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식을 의미한다. 
지연된 조인은 주로 LIMIT이 함께 사용된 쿼리에서 더 큰 효과를 얻을 수 있다.

ex)
SELECT e.*
  FROM salaries s, employees e
 WHERE e.emp_no=s.emp_no
   AND s.emp_no BETWEEN 10001 AND 13000
 GROUP BY s.emp_no
 ORDER BY SUM(s.salary) DESC
 LIMIT 10;
 
-> 지연된 조인으로 변경
SELECT e.*
  FROM (SELECT s.emp_no
          FROM salaries s
         WHERE s.emp_no BETWEEN 10001 AND 13000
         GROUP BY s.emp_no
         ORDER BY SUM(s.salary) DESC
         LIMIT 10) x,
       employees e
 WHERE e.emp_no=x.emp_no;
실행 계획을 보게 되면 서브쿼리의 결과를 derived2로 처리된다. 
단순 실행 계획만 보게되면 변경전 쿼리보다 느리다고 예상할 수 있지만, 실제 서브쿼리로 인해 e 테이블과 조인하게 되는 임시 테이블의 레코드가 10건으로 
줄어들었으므로 3~4배 정도는 더 빠르게 실행된다는 것을 알 수 있다.
원리를 정확히 이해하고 작성하는게 중요하며 잘 튜닝된다면 몇십, 몇백 배 더 나은 성능을 보일 수도 있다.

지연된 조인을 사용하기 위해 필요한 조건  ****
- LEFT (OUTER) JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1또는 M:1 관계여야한다.
- INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1또는 M:1의 관계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야
한다. 두 번째와 세 번째 조건은 드라이빙 테이블을 서브쿼리로 만들고 이 서브쿼리에 LIMIT을 추가해도 최종 결과의 건수가 변하지 않는다는 보증을 해주는
조건이기 때문에 반드시 정확히 확인한 후 적용해야 한다.

래터럴 조인
8.0 이전 버전까지는 그룹별로 몇 건씩만 가져오는 쿼리를 작성할 수가 없었다. 하지만 8.0부터는 래터럴 조인이라는 기능을 이용해 특정 그룹별로 서브쿼리를
실행해서 그 결과와 조인하는 것이 가능해졌다.
ex)
SELECT *
  FROM employees e
  LEFT JOIN LATERAL (SELECT *
                       FROM salaries s
                      WHERE s.emp_no=e.emp_no
                      ORDER BY s.from_date DESC LIMIT 2) s2 ON s2.emp_no=e.emp_no
 WHERE e.first_name='Matt';
해당 쿼리는 employees 테이블에서 이름이 'Matt'인 사원에 대해 사원별로 가장 최근 급여 변경 내역을 최대 2건씩만 반환한다.
래터럴 조인에서 가장 중요한 부분은 FROM 절에 사용된 서브쿼리에서 외부 쿼리의 FROM 절에 정의된 테이블의 칼럼을 참조할 수 있다는 것이다.(e.emp_no사용)
* LATERAL 키워드를 가진 서브쿼리는 조인 순서상 후순위로 밀리고, 외부 쿼리의 결과 레코드 단위로 임시 테이블이 생성되기 때문에 꼭 필요한 경우에만
사용해야 한다.
 
실행 계획으로 인한 정렬 흐트러짐
8.0 이전 버전까지는 네스티드 루프 방식의 조인만 가능했지만 8.0부터는 해시 조인 방식이 도입됐다. 네스티드 루프 조인은 알고리즘의 특성상 
드라이빙 테이블에서 읽은 레코드의 순서가 다른 테이블이 모두 조인돼도 그대로 유지된다. 그래서 Mysql에서 조인을 사용하는 쿼리의 결과는 드라이빙 테이블을
읽은 순서로 정렬된다고 생각할 때가 많다. 실제로도 주어진 조건에 의해 드라이빙 테이블을 인덱스 스캔이나 풀 테이블 스캔을 하고, 그때 드라이빙 테이블을
읽은 순서가 그대로 최종 결과에 반영된다.

하지만 쿼리의 실행 계획에서 네스티드 루프 조인 대신 해시 조인이 사용되면 쿼리 결과의 레코드 정렬 순서가 달라진다. 
해시 조인 뿐만 아니라 Mysql 8.0 이전 버전에서 사용되던 블록 네스티드 루프 조인이 사용되는 경우도 동일하게 쿼리 결과의 정렬 순서가 드라이빙 테이블을
읽는 순서와 다르게 출력됐다.

ex)
SELECT e.emp_np, e.first_name, e.last_name, de.from_date
  FROM dept_emp de, employees e
 WHERE de.from_date>'2001-10-01' AND e.emp_no<10005;
EXPLAIN) Extra - Using where; Using index; Using join buffer(hash join)
해당 쿼리의 결과를 확인하면 emp_no으로 정렬되어 있지 않고 emp_no가 반복적으로 순환되는 결과를 확인할 수 있다.
이처럼 해시조인을 순서가 바뀔 수 있다.

GROUP BY
WITH ROLLUP
GROUP BY가 사용된 쿼리에서는 그루핑된 그룹별로 소계를 가져올 수 있는 롤업 기능을 사용할 수 있다.
ROLLUP으로 출력되는 소계는 단순히 최종 합만 가져오는 것이 아니라 GROUP BY에 사용된 칼럼의 개수에 따라 소계의 레벨이 달라진다. (엑셀의 피벗 테이블 비슷)
ex)
SELECT dept_np, COUNT(*)
  FROM dept_emp
 GROUP BY dept_no WITH ROLLUP;
소계 레코드의 칼럼값은 항상 NULL로 표시된다는 점을 주의해야 한다. GROUP BY 칼럼이 2개라면 소계 마지막에 총계로 나타낸다.
8.0부터는 그룹 레코드에 표시되는 NULL을 사용자가 변경할 수 있게 GROUPING() 함수를 지원한다. (p98)

레코드를 칼럼으로 변환해서 조회
GROUP BY나 집합 함수를 통해 레코드를 그루핑할 수 있지만 하나의 레코드를 여러 개의 칼럼으로 나누거나 변환하는 SQL 문법은 없다. 하지만 SUM()이나 COUNT()
같은 집합 함수와 CASE WHEN ... END 구문을 이용해 레코드를 칼럼으로 변환하거나 하나의 칼럼을 조건으로 구분해서 2개 이상의 칼럼으로 변환하는 것은 가능하다.
(P99) 예제 참고

ORDER BY 
ORDER BY는 검색된 레코드를 어떤 순서로 정렬할지 결정한다. 
ORDER BY 절이 사용되지 않았을 때 정렬 방법
1) 인덱스를 사용한 SELECT의 경우에는 인덱스에 정렬된 순서대로 레코드를 가져온다.
2) 인덱스를 사용하지 못하고 풀 테이블 스캔을 실행할 경우
 - MyISAM 테이블은 테이블에 저장된 순서대로 가져오는데, 이 순서가 정확히 INSERT의 순서는 아닐 수 있다. 일반적으로 레코드가 삭제되면서 빈공간이 생기고,
   INSERT 되는 레코드를 항상 테이블의 마지막이 아니라 빈 공간이 있으면 그 빈 공간에 저장되기 때문이다.
 - InnoDB 항상 프라이머리 키로 클러스터링돼 있기 때문에 풀 테이블 스캔의 경우에도 기본적으로 프라이머리 키 순서대로 레코드를 가져온다.
3) SELECT 쿼리가 임시 테이블을 거쳐 처리되면 조회되는 레코드의 순서를 예측하기는 어렵다.

어떤 DBMS도 ORDER BY 절이 명시되지 않은 쿼리에 대해서는 어떠한 정렬도 보장하지 않는다. 항상 정렬이 필요한 곳에서는 ORDER BY절을 사용해야 한다.

ORDER BY에서 인덱스를 사용하지 못할 때는 추가 정렬 작업이 수행되며, Extra 칼럼에 Using filesort가 표시. 
-> 쿼리를 수행하는 도중에 Mysql 서버가 명시적으로 정렬알고리즘을 수행했다는 의미 정도로 이해하면 된다.
show status likt 'Sort_%';
Sort_merge_passes - 메모리의 버퍼(sort_buffer_size)와 디스크에 저장된 레코드를 몇 번이나 병합했는지 (0보다 크다면 데이터가 정렬용 버퍼보다 커서 디스크이용)
Sort_range - 인덱스 레인지 스캔을 통해 읽은 레코드를 정렬한 횟수 누적 값
Sort_rows - 정렬을 수행했던 전체 레코드 건수의 누적 값
Sort_scan - 풀 테이블 스캔을 통해서 읽은 레코드를 정렬한 횟수 누적 값

ORDER BY 사용법 및 주의사항
ORDER BY 2는 인식하지만 ORDER BY "last_name"은 인식하지 못한다 Mysql은 쌍따옴표를 문자열 리터럴로 인식하기 때문이다 (sql_mode 기본 변수)

여러 방향으로 동시 정렬
8.0부터는 오름차순, 내림차순 혼용으로 인덱스 생성이 된다. 
ex) ALTER TABLE salaries ADD INDEX ix_salary_fromdate (salary DESC, from_date ASC);

함수나 표현식을 이용한 정렬
8.0부터 함수 기반의 인덱스를 지원한다. 
ex) SELECT * FROM salaries ORDER BY COS(salary);


서브쿼리
쿼리를 작성할 때 서브쿼리를 사용하면 단위 처리별로 쿼리를 독립적으로 작성할 수 있다. 조인처럼 여러 테이블을 섞어 두는 형태가 아니어서 쿼리의 가독성도
높아지며, 복잡한 쿼리도 손쉽게 작성할 수 있다. 5.6까지는 서브쿼리를 최적으로 실행하지 못할 때가 많았지만, 8.0부터는 많이 개선되었다.

SELECT 절에 사용된 서브 쿼리
SELECT 절에 사용된 서브쿼리는 내부적으로 임시 테이블을 만들거나 쿼리를 비효율적으로 실행하게 만들지는 않기 때문에 서브쿼리가 적절히 인덱스를
사용할 수 있다면 크게 주의할 사항은 없다.
일반적으로 SELECT 절에 서브쿼리를 사용하면 그 서브쿼리는 항상 칼럼과 레코드가 하나인 결과를 반환해야 한다. 그 값이 NULL이든 아니든 관계없이 
레코드가 1건이 존재해야 한다는 것인데, Mysql에서는 이 체크 조건이 조금은 느슨하다.
+ 2건 이상의 레코드를 반환하면 안되고, 2개 이상의 칼럼을 가져오려고 해도 에러가 발생한다. 결과가 0건일 경우 NULL로 채워져서 반환된다.

8.0의 래터럴 조인은 한 가지 문제점이 있다. 예제(p108)
-> 인덱스를 이용해 충분히 정렬된 결과를 가져올 수 있음에도 불구하고 정렬을 실행하여 Handler_read_next 값이 증가했다. 이는 버그로 식별됐다.

FROM 절에 사용된 서브쿼리 
이전 버전의 Mysql 서버에서는 FRMO 절에 서브쿼리가 사용되면 항상 서브쿼리의 결과를 임시 테이블로 저장하고 필요할 때 다시 임시 테이블을 읽는 
방식으로 처리했다. 그래서 가능하면 FROM 절의 서브 외부 쿼리로 병합하는 형태로 쿼리 튜닝을 했다. 하지만 5.7부터는 옵티마이저가 FROM 절의 서브쿼리를
외부 쿼리로 병합하는 최적화를 수행하도록 개선됐다.

EXPLAIN 명령을 실행한 후 SHOW WARNINGS 명령을 실행하면 Mysql 서버가 서브쿼리를 병합해서 재작성한 쿼리의 내용을 확인할 수 있다. 
ex) EXPLAIN SELECT * FROM (SELECT * FROM employees) y;    (p110)
서브쿼리의 외부 쿼리 병합은 꼭 FROM절의 서브쿼리에 대해서만 적용되는 최적화는 아니다. FROM 절에 사용된 뷰의 경우에도 Mysql 옵티마이저는
뷰 쿼리와 외부 쿼리를 병합해서 최적화된 실행 계획을 사용한다.

FROM 절의 모든 서브쿼리를 외부 쿼리로 병합할 수 있는 것은 아니다. 
대표적으로 다음과 같은 기능이 서브쿼리에 사용되면 FROM 절의 서브 쿼리는 외부 쿼리로 병합되지 못한다.

- 집합 함수 사용(SUM(), MIN(), MAX(), COUNT() 등)
- DISTINCT
- GROUP BY 또는 HAVING
- LIMIT
- UNION(UNION DISTICNT) 또는 UNION ALL
- SELECT 절에 서브쿼리가 사용된 경우
- 사용자 변수 사용(사용자 변수에 값이 할당되는 경우)

외부 쿼리와 병합되는 FROM 절의 서브쿼리가 ORDER BY 절을 가진 경우에는 외부 쿼리가 GROUP BY나 DISTINCT 같은 기능을 사용하지 않는다면 서브쿼리의
정렬 조건을 외부 쿼리로 같이 병합한다. 외부 쿼리에서 GROUP BY나 DISTINCT와 같은 기능이 사용되고 있다면, 서브쿼리의 정렬 작업은 무의미하기 떄문에
서브쿼리의 ORDER BY 절은 무시된다.

Mysql 서버에서 FROM 절의 서브쿼리를 외부 쿼리로 병합하는 최적화는 optimizer_switch 시스템 변수로 제어할 수 있다. (9.3.1.16 파생 테이블 머참조)

WHERE 절에 사용된 서브쿼리
SELECT, FROM 절보다 다양한 형태(연산자)로 사용될 수 있는데, 크게 3가지로 구분할 수 있따.
- 동등 또는 크다 작다 비교 (= (subquery))
- IN 비교 (IN (subquery))
- NOT IN 비교 (NOT IN (subquery))

동등 또는 크다 작다 비교
5.5 이전 버전까지는 서브쿼리 외부의 조건으로 쿼리를 실행하고, 최종적으로 서브쿼리를 체크 조건으로 사용했다. 하지만 이러한 처리 방식의 경우
풀 테이블 스캔이 필요한 경우가 많아서 성능 저하가 심각했다.
ex)
SELECT * FROM dept_emp de
 WHERE de.emp_no=(SELECT e.emp_no
                    FROM employees e
                   WHERE e.first_name='Georgi' AND e.last_name='Facello' LIMIT 1);
5.5 이전 버전까지는 위 쿼리의 경우 dept_emp 테이블을 풀 스캔하면서 서브쿼리의 조건에 일치하는지 여부를 체크했다.
5.5 버전 부터는 이 쿼리의 실행 계획은 그 이전 버전과는 정반대로 실행되도록 개선됐다. 서브쿼리를 먼저 실행한 후 상수로 변환한다. 그리고 상숫값으로
서브쿼리를 대체해서 나머지 쿼리 부분을 처리한다. (실행 계획 p112)
여기서는 동등 비교만 예시로 살펴봤지만 동등 비교 대신 크다 또는 작다 비교가 사용돼도 동일한 실행 계획을 사용한다.

ex)
SELECT * 
  FROM dept_emp de WHERE (emp_no, from_date) = (SELECT emp_no, from_date ~~~ limit 1);
위와 같이 단일 값 비교가 아닌 튜플 비교 방식이 사용되면 서브쿼리가 먼저 처리되어 상수화되긴 하지만 외부 쿼리는 인덱스를 사용하지 못하고 풀 테이블 스캔을
실행하는 것을 확인할 수 있다. 8.0이라고 하더라도 아직 튜플 형태의 비교는 주의해서 사용해야 한다.
  
IN 비교
실제 조인은 아니지만 다음 예제와 같이 테이블의 레코드가 다른 테이블의 레코드를 이용한 표현식과 일치하는지를 체크하는 형태를 세미 조인이라고 한다.
즉 WHERE 절에 사용된 IN (subquery) 형태의 조건을 조인의 한 방식인 세미 조인이라고 보이는 것이다.
ex)
SELECT *
  FROM employees e
 WHERE e.emp_no IN (SELECT de.emp_no
                      FROM dept_emp de WHERE de.from_date='1995-01-01');

5.5 까지는 세미 조인의 최적화가 매우 부족해서 대부분 풀 테이블 스캔을 했다. 그래서 이런 세미 조인 형태는 Mysql 서버에서 사용하면 안 되는 패턴으로 
기억하는 사용자가 많을 것이다. 하지만 5.6부터는 최적화가 많이 개선되면서 이제 더 이상은 IN 형태를 2개의 쿼리로 쪼개어 실행하거나 다른 우회 방법을 
찾을 필요가 없어졌다.

세미 조인 최적화는 쿼리 특성이나 조인 관계에 맞게 다음과 같이 5개의 최적화 전략을 선택적으로 사용한다. (9.3.1.9 세미조인 참조)
- 테이블 풀 아웃(Table Pull-out)
- 퍼스트 매치(First Match)
- 루스 스캔(Loosescan)
- 구체화(Materialization)
- 중복 제거(Duplicated Weed-out)

NOT IN 비교
IN과 비슷하지만 이 경우를 안티 세미 조인이라고 명명한다. 일반적인 RDBMS에서 Not-Equal 비교는 인덱스를 제대로 활용할 수 없듯이 안티 세미 조인 또한
최적화할 수 있는 방법이 많지 않다. Mysql 옵티마이저는 안티 세미 조인 쿼리가 사용되면 다음 두 가지 방법으로 최적화를 수행한다.
- NOT EXISTS
- 구체화(Materialization)
두 최적화 모두 그다지 성능 향상에 도움이 되지 않는 방법이므로 쿼리가 최대한 다른 조건을 활용해서 데이터 검색 범위를 좁힐 수 있께 하는 것이 좋다.
WHERE 절에 단독으로 안티 세미 조인 조건만 있다면 풀 테이블 스캔을 피할 수 없으니 조심해야 한다.

CTE(Common Table Expression) ** 8.0
CTE는 이름을 가지는 임시 테이블로서, SQL 문장 내에서 한번 이상 사용될 수 있으며 SQL 문장이 종료되면 자동으로 CTE 임시 테이블은 삭제된다.
CTE는 재귀적 반복 실행 여부를 기준으로 Non_recursive와 Recursive CTE로 구분된다. 
Mysql 서버의 CTE는 재귀 여부에 관계없이 다음과 같이 다양한 SQL 문장에서 사용할 수 있다.

* SELECT, UPDATE, DELETE 문장의 제일 앞쪽
- WITH cte1 AS (SELECT ...) SELECT ...
- WITH cte1 AS (SELECT ...) UPDATE ...
- WITH cte1 AS (SELECT ...) DELETE ...

* 서브쿼리의 제일 앞쪽
- SELECT ... FROM ... WHERE id IN (WITH cate1 AS (SELECT ...) SELECT ...) ...
- SELECT ... FROM (WITH cte1 AS (SELECT ...) SELECT ...) ...

* SELECT 절의 바로 앞쪽
- INSERT ... WITH cte1 AS (SELECT ...) SELECT ...
- REPLACE ... WITH cte1 AS (SELECT ...) SELECT ...
- CREATE TABEL ... WITH cte1 AS (SELECT ...) SELECT ...
- CREATE VIEW ... WITH cte1 AS (SELECT ...) SELECT ...
- DECLARE CURSOR ... WITH cte1 AS (SELECT ...) SELECT ...
- EXPLAIN  ... WITH cte1 AS (SELECT ...) SELECT ...

비 재귀적 CTE(Non-Recursive CTE)
Mysql 서버에서는 ANSI 표준을 그대로 이용해서 WITH 절을 이용해 CTE를 정의한다.
ex_1)
WITH cte1 AS (SELECT * FROM departments)
SELECT * FROM cte1;

ex_2)
SELECT * 
  FROM (SELECT * FROM departments) cte1;
  
실제 두 쿼리는 실행 계획까지 동일하게 사용한다.

ex_3) 
WITH cte1 AS (SELECT * FROM departments),
     cte2 AS (SELECT * FROM dept_emp)
SELECT *
  FROM cte1
 INNER JOIN cte2 ON cte2.dept_no=cte1.dept_no;
  
위와 같이 여러 개의 임시 테이블을 하나의 쿼리에서 사용할 수도 있다.

임시 테이블이 여러 번 사용되는 쿼리는 둘의 실행 계획이 조금 달라진다.
ex) (p116)
1. salaries를 cte1 테이블로 선언 후 employees e 테이블과 cte t1, cte t2 를 조인할 경우
2. employees e 테이블을 salaries t1, salaries t2와 조인할 경우

1의 경우엔 salaries 테이블을 이용한 cte1 임시 테이블(<derived2>)을 한 번만 생성하지만 2의 경우엔 2개의 임시 테이블(<derived2>와 <derived3>)을
생성하기 위해서 각 서브쿼리에서 salaries 테이블을 읽는다. 

그리고 CTE로 생성된 임시 테이블은 다른 CTE 쿼리에서 참조할 수 있다는 장점도 있다.
ex) (p117)
cte1을 선언 후 cte2를 선언할 때 cte1 테이블을 이용해서 조인할 수 있다. 

이렇게 WITH 절에 정의된 순서대로 CTE 임시 테이블은 재사용될 수 있는데, 
WITH 절에서 뒤에 정의된 cte2 테이블을 먼저 선언된 cte1의 CTE 쿼리에서는 참조할 수 없다.

CTE를 재귀적으로 사용하지 않더라도 기존 FROM 절에 사용되던 서브쿼리에 비해 다음의 3가지 장점이 있다. 
- CTE 임시 테이블은 재사용 가능하므로 FROM 절의 서브쿼리보다 효율적이다.
- CTE로 선언된 임시 테이블을 다른 CTE 쿼리에서 참조할 수 있다.
- CTE는 임시 테이블의 생성 부분과 사용 부분의 코드를 분리할 수 있으므로 가독성이 높다.

재귀적 CTE(Recursive CTE)
재귀 쿼리는 아마도 많은 Mysql 사용자가 기다리던 기능일 것이다. 데이터베이스 업계에서는 윈백(Win Back)프로젝트라는 말을 자주 듣는다.
윈백 프로젝트에서 많은 사용자가 특정 기능이 없어서 Mysql 서버를 사용하기 어렵다고 이야기했는데, 그중에서 가장 대표적인 기능이 재귀 쿼리였다.
Mysql 8.0버전에서야 비로소 CTE를 이용한 재귀 쿼리가 가능해졌다. * 윈백(다른 DBMS를 사용하다가 특정 DBMS로 다시 돌아가는, 기능, 처리성능의 부재로 인한)

ex) 
WITH RECURSIVE cte (no) AS (
SELECT 1
 UNION ALL
SELECT (no + 1) FROM cte WHERE no < 5
)
SELECT * FROM cte;

비 재귀적 CTE는 단순히 쿼리를 한 번만 실행 그 결과를 임시 테이블로 저장한다. 재귀적 CTE쿼리는 비 재귀적 쿼리 파트와 재귀적 파트로 구분되며,
이 둘을 UNION(UNION DISTINCT) 또는 UNION ALL로 연결하는 형태로 반드시 쿼리를 작성해야 한다. 위의 예에제서 UNION ALL 위쪽은 비 재귀적 파트이며,
UNION ALL 아래는 재귀적 파트다. 비 재귀적 파트는 처음 한 번만 실행되지만 재귀적 파트는 쿼리 결과가 없을 때까지 반복 실행된다.

위의 예제 쿼리가 작동하는 방법
1. CTE 쿼리의 비 재귀적 파트의 쿼리를 실행
2. 1번의 결과를 이용해 cte라는 이름의 임시 테이블 생성
3. 1번의 결과를 cte라는 임시 테이블에 저장
4. 1번 결과를 입력으로 사용해 CTE 쿼리의 재귀적 파트의 쿼리를 실행
5. 4번의 결과를 cte라는 임시 테이블에 저장(이때 UNION 또는 UNION DISTINCT의 경우 중복 제거를 실행)
6. 전 단계의 결과를 입력으로 사용해 CTE 쿼리의 재귀적 파트 쿼리를 실행
7. 6번 단계에서 쿼리 결과가 없으면 CTE 쿼리를 종료
8. 6번의 결과를 cte라는 임시 테이블에 저장
9. 6번으로 돌아가서 반복 실행

비 재귀적 파트의 결과와 재귀적 파트의 결과에서 칼럼 개수나 칼럼의 타입, 칼럼 이름이 서로 다른 경우 Mysql 서버는 비 재귀적 파트에 정의된 결과를 사용한다.
재귀적 쿼리 파트를 실행할 때는 지금까지의 모든 단계에서 만들어진 결과 셋이 아니라 직전 단계의 결과만 재귀 쿼리의 입력으로 사용된다.

모든 재귀 쿼리에는 no < 5 같은 조건이 필요할 것처럼 보이지만 ** 실제 재귀 쿼리가 반복을 멈추는 조건은 재귀 파트 쿼리의 결과가 0건일 때까지다.

기본적으로 CTE 쿼리로 만들어지는 임시 테이블의 칼럼 이름과 각 칼럼의 데이터 타입은 비 재귀적 쿼리 파트의 결과를 그대로 차용한다.
칼럼명을 변경하고자 한다면 CTE 별명 뒤에 새로운 이름을 부여할 수 있다.
ex) WITH cte1 (fd1, fd2, fd3) AS (SELECT * FROM departments)
    SELECT * FROM cte1;

데이터의 오류나 쿼리 작성자의 실수로 재귀적 CTE가 종료 조건을 만족하지 못해서 무한 반복하는 경우 cte_max_recursion_depth 시스템 변수를 이용해
최대 반복 실행 횟수를 제한할 수 있다. 기본값은 1000이며 가능하면 적절히 낮은 값으로 변경하여 사용하고, 꼭 필요한 쿼리에서만 SET_VAR 힌트를 이용해
해당 쿼리에서만 반복 호출 횟수를 늘리는 방법을 권장한다.
ex)
WITH RECURSIVE cte (no) AS (...)
SELECT /*+ SER_VAR(cte_max_recursion_depth=10000) */ * FROM cte;

재귀적 CTE 활용 (p122-125)

윈도우 함수
윈도우 함수는 조회하는 현재 레코드를 기준으로 연관된 레코드 집합의 연산을 수행한다. 집계 함수는 주어진 그룹(GROUP BY 절에 나열된 칼럼의 값에 따른 그룹
또는 GROUP BY 절 없이 전체 그룹)별로 하나의 레코드로 묶어서 출력하지만 윈도우 함수는 조건에 일치하는 레코드 건수는 변하지 않고 그대로 유지한다.
이것이 윈도우 함수와 집계 함수의 가장 큰 차이점이라고 할 수 있다.

일반적인 SQL 문장에서 하나의 레코드를 연산할 때 다른 레코드의 값을 참조할 수 없는데, 예외적으로 GROUP BY 또는 집계 함수를 이용하면 다른 레코드의
칼럼값을 참조할 수 있다. 하지만 GROUP BY 또는 집계 함수를 사용하면 결과 집합의 모양이 바뀐다. 그에 반해 윈도우 함수는 결과 집합을 그대로 유지하면서
하나의 레코드 연산에 다른 레코드의 컬럼값으 참조할 수 있다.

쿼리 각 절의 실행 순서
윈도우 함수를 사용하는 쿼리의 결과에 보여지는 레코드는 FROM절, WHERE절 GROUP BY와 HAVING 절에 의해 결정되고, 그이후 윈도우 함수가 실행된다.
그리고 마지막으로 SELECT 절과 ORDER BY 절, LIMIT 절이 실행되어 최종 결과가 반환된다. 

쿼리에서 각 절의 실행 순서를 숙지하고 있어야 정확한 쿼리를 작성할 수 있다.



















