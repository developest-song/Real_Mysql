환경 
CentOS 7 사용 
mysql 8.0.21 
 
mysql 설치 
yum으로 설치 (root로 진행)
yum repository 설치용 rpm 다운로드 ( dev.mysql.com/downloads/repo/yum )
mysql에 올리고 rpm -Uvh mysql80-community-release-el7-3.noarch.rpm

설치 가능한 mysql 소프트웨어 목록 yum search mysql-community 

설치가능한 버전 yum –showduplicates list mysql-community-server

실제 설치 yum install mysql-community-server-8.0.21

시작 systemctl start mysqld / 종료 systemctl stop mysqld

접속 /var/log/mysqld.log에 임시로 저장된 비밀번호 
mysql -u root -p  password : 

비밀번호 변경 (편의상 LOW로 변경)
기본 정책 : Medium / 8자리 이상 대문자 1자, 숫자 1자, 특수문자 1자 이상(validate_password%)
LOW – 비밀번호 길이만 검증
MEDIUM – 길이, 숫자, 대소문자, 특수문자 배합 검증
STRONG – MEDIUM + 금칙어 포함 여부 검증

alter user root@localhost identified by ‘test123’;
create user root@’%’ identified by ‘test123’;
grant all privileges on *.* to root@'%';  (계정생성과 권한을 따로 줘야한다)

toad 접속 시 - Unable to load authentication plugin 'caching_sha2_password'
vi /etc/my.cnf 추가 - default_authentication_plugin=mysql_native_password 

mysql -u root -p --host=localhost (socket을 통해 IPC 통신)
mysql -u root -p –host=127.0.0.1 (루프백 IP - TCP/IP 통신)

인플레이스 업그레이드 제약 사항
1)	동일 메이저 버전에서 마이너 버전 간 업그레이드할 경우 ex) 8.0.16 -> 8.0.21 
대부분 데이터 파일의 변경 없이 진행
2)	메이저 버전 간 업그레이드 일 경우 5.5 -> 5.6 가능 5.5 -> 5.7 or 8.0 지원하지 않음
데이터 파일의 패치 시 직전 메이저 버전에서 사용하던 데이터 파일과 로그 포맷만 인식하도록 구현되기 때문
* 새로운 버전을 선택할 때 최소 GA 버전은 지난(15~ 20번 이상) 마이너 버전을 선택
- 오라클에서 mysql 서버의 안정성이 확인된 버전을 의미 
인플레이스 업그레이드가 안 될수 있음 

mysql 8.0 업그레이드 시 고려사항
1)	사용자 인증 방식 변경 – Native Authentication -> Caching SHA-2 Authentication
2)	호환성 체크 : 손상된 FRM 파일, 호환되지 않는 데이터 타입, 함수 확인(mysqlcheck)
3)	외래키 이름의 길이 : 64글자로 제한 
4)	인덱스 힌트 : 8.0에서 힌트의 성능 테스트 필요 (성능 저하 유발 가능)
5)	group by 정렬 옵션 : ‘ASC’, ‘DESC’ 사용 시 제거하거나 다른 방식으로 변경
6)	공용 테이블스페이스 : 파티션의 각 테이블 스페이스를 공용 테이블스페이스에 저장할 수 없다. 확인 후 개별 테이블스페이스를 사용하도록 변경
 
시스템 변수
Cmd-Line – 명령행 인자로 설정될 수 있는지 여부 
Option File – my.cnf로 제어 가능한지 여부
System Var – 시스템 변수 여부
Var Scope – Global, Session, Both 영향 여부
Dynamic – 동적, 정적 변수 여부 (동적 : mysql 재시작하지 않고 변경 가능)

ex) show global variables like ‘%max_connections%’; 
max_connections 패턴으로 서버 전체 영향 미치는 변수를 조회 
both 타입의 변수 일 경우 set global로 변숫값 변경 시 session 값에는 영향이 없다

set persist 변수 변경과 함께 설정 파일(mysqld-auto.cnf : JSON형식)에 적용 
* 세션변수에는 적용 되지 않음
ex) set persist max_connections=5000;
ex) set persist_only max_connections=5000; // 설정파일에만 변경 내용 저장
특정 시스템 변수 삭제 
reset persist max_connections; // mysqld-auto.cnf 내용상 오류 차단을 위해 
reset persist;
 
사용자 및 권한
계정으로 로그인 할 때 같은 계정, 다른 IP일 경우 IP의 범위가 좁은 것을 우선으로 한다.
ex) test@192.168.0.132 > test@%
mysql.sys@localhost – sys 스키마의 객체들의 DEFINER 계정
mysql.session@localhost – mysql 플러그인이 서버로 접근할 때 사용되는 계정
mysql.infoschema@localhost – information_schema에 정의된 뷰의 DEFINER 계정

계정 생성
CREATE USER ‘user’@’%’
	IDENTIFIED WITH ‘mysql_native_password’ BY ‘password’ (인증방식 및 비밀번호)
		IDENTIFIED BY ‘password’ (서버의 기본 인증 방식 사용)
		 Caching SHA-2 Pluggable Authentication
SCRAM사용 5000번 암호화 해시 함수 실행(brute-force 대응, but 자원소모 큼)
	REQUIRE NONE // 서버 접속 시 암호화된 SSL/TLS 채널 사용 여부 설정
	PASSWORD EXPIRE INTERVAL 30 DAY // 비밀번호 유효기간 
	ACCOUNT UNLOCK // 계정 잠금 여부 
	PASSWORD HISTORY DEFAULT // 비밀번호 재사용 여부
	PASSWORD REUSE INTERVAL DEFAULT // 비밀번호 재사용 금지 기간 설정
	PASSWORD REQUIRE CURRENT DEFAULT; // 만료 후 새 설정, 현재 비밀번호 필요 여부

Dual Password – 2개의 비밀번호 중 한 개만 일치하면 로그인(Primary, Secondary)
ex) ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘new_password’ RETAIN CURRENT PASSWORD;
 
권한
객체 권한 - DB, Table 제어 시 필요한 권한
	GRANT 권한 부여 시 특정 객체 명시
	DB권한
	ex) GRANT EVENT ON *.* TO 'user'@'localhost';
	    GRANT EVENT ON employees.* TO 'user'@'localhost'; // 둘다 사용 가능, but 테이블에 까지는 적용 불가(db.table)
	테이블 권한
	ex) GRANT SELECT,INSERT,UPDATE,DELETE ON *.* TO 'user'@'localhost';
	    GRANT SELECT,INSERT,UPDATE,DELETE ON employees.department TO 'user'@'localhost';
	    GRANT SELECT,INSERT,UPDATE(dept_name) ON employees.department TO 'user'@'localhost'; // 컬럼 단위 권한
	** 칼럼 단위의 권한이 하나라도 설정되면 나머지 모든 테이블의 모든칼럼에 대해서도 권한 체크를 하기 때문에 전체적인 성능에 영향을 미칠 수 있음
	   꼭 필요하다면 뷰를 선택하는것도 방법 
	   
글로벌 권한 – DB, Table 이외의 객체에 적용되는 권한
	GRANT 권한 부여 시 특정 객체 명시X
	ex) GRANT SUPER ON *.* TO 'user'@'localhost'; // 특정 DB, 테이블에 부여하지 못하기에 항상 *.* 사용
예외적으로 ALL은 글로벌, 객체 권한 두 가지 용도로 사용 가능
	8.0부터 동적 권한 추가
동적 권한 – mysql 서버의 컴포넌트나 플러그인이 설치되면 그때 등록되는 권한 

Role - 권한을 묶어서 역할로 사용
ex)
create role role_emp_read, role_emp_write; // 껍데기 선언
grant select on employees.* to role_emp_read; // 권한 부여
grant insert, update, delete on employees.* to role_emp_write; // 권한 부여
create user reader@'127.0.0.1' identified by 'qwerty12'; // 계정 생성
create user writer@'127.0.0.1' identified by 'qwerty12'; // 계정 생성
grant role_emp_read to reader@'127.0.0.1'; // 역할 부여
grant role_emp_read, role_emp_write to writer@'127.0.0.1' // 역할 부여
set role 'role_emp_read'; // 역할 활성화
select current_role(); // 역할 확인
activate_all_roles_on_login=ON // 역할 자동화 활성 변수

역할과 계정은 동일한 객체로 취급 (관리자 입장에서 prefix를 지정해서 관리해야함)

아키텍처
머리를 담당하는 Mysql엔진, 손발을 담당하는 스토리지 엔진으로 나누어짐 
Mysql엔진 - 커넥션 핸들러, SQL파서, 전처리기, 옵티마이저 
스토리지엔진 - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어온다. (InnoDB(버퍼풀), MyISAM(키캐시), Memory ...)
핸들러 API - Mysql엔진의 쿼리실행기에서 데이터를 쓰거나 읽을 때, 각 스토리지 엔진에 쓰기, 읽기를 요청함 
	show global status like 'handler%'; (핸들러 API를 통한 데이터 작업량 확인)

Mysql 스레딩 구조 - 스레드 기반으로 작동, 포그라운드 + 백그라운드 (performance_schema.threads - 실행중인 스레드 목록)
포그라운드 스레드 - mysql 서버에 접속된 클라이언트의 수만큼 존재, 커넥션 종료 시 스레드 캐시로 돌아가며, 대기중인 개수가 일정이상일 경우 스레드 종료
 유지하는 최대 스레드 개수 - thread_cache_size 변수 
 MyISAM - 데이터 버퍼, 캐시로부터 데이터를 가져오고, 디스크 쓰기 작업까지
 InnoDB - 데이터 버퍼, 캐시까지만 디스크 쓰기는 백그라운드 스레드가 처리
 이처럼 나누어  InnoDB는 쓰기 전까지 기다리지 않고 SELECT만 가능
백그라운드 스레드 - InnoDB의 백그라운드 스레드
 인서트버퍼 병합 스레드
 로그 스레드
 쓰기 스레드
 읽기 스레드
 잠금, 데드락 모니터링 스레드
 읽기, 쓰기 스레드 갯수 지정 변수 - innodb_read_io_threads, innodb_write_io_threads 

글로벌 메모리 영역 - 생성된 글로벌 메모리 영역 N개는 모든 스레드에 의해 공유 
 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리두 로그 버퍼

로컬 메모리 영역 - 각 클라이언트 스레드별로 독립적으로 할당, 절대 공유, 사용되지 않음
 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

Mysql엔진이 스토리지 엔진을 조정하기 위해선 핸들러를 사용해야 한다.

플러그인의 단점
 오직 Mysql서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
 Mysql서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

쿼리 파서
 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
 쿼리의 기본 문법 오류는 이 과정에서 발생, 사용자에게 오류 메시지 전달

전처리기
 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
 각 테이블 이름, 칼럼 이름, 내장 함수와 같은 개체를 매핑하고 해당 객체 존재 여부, 접근 권한 등을 확인
 존재 하지 않거나, 권한 상 사용할 수 없는 토큰은 이 과정에서 걸러짐

옵티마이저
 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정 ( 중 요 )
 
실행 엔진
 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행
 
핸들러(스토리지 엔진)
 Mysql서버의 가장 밑단에서 Mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당

쿼리 캐시
 SQL의 실행 결과를 메모리에 캐시, 동일 쿼리가 실행되면 즉시 결과 반환 but 테이블의 데이터가 변경 될 시 관련된 것 삭제 -> 동시 처리 성능 저하 유발
 결과적으로 mysql 8.0에서 기능 완전 삭제

스레드 풀 (엔터프라이즈 에디션 O, 커뮤니티 에디션 X) -> **Percona Server 스레드풀**(thread_pool.so 스레드 풀 플러그인 라이브러리 설치 필요)
 동시 처리 요청이 많아도 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원소모를 줄이는 것이 목적
 스케줄링에 문제가 생기면 오히려 쿼리 처리가 느려질 수도 있음
 CPU코어의 개수와 thread_pool_size 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는데 좋음
 thread_pool_oversubscribe (추가로 더 받아들여서 처리할 수)
 thread_pool_stall_limit 정의된 밀리초만큼 작업이 끝나지 않으면 새로운 스레드 생성
 thread_pool_max_threads 최대 스레드 수 
 선순위 큐, 후순위 큐를 이용해 순서를 재배치 할 수 있음 
 
트랜잭션 지원 메타데이터
 5.7까지는 테이블 구조를 FRM에 저장 + (*.TRM, *.TRG, *.PAR, ...) -> 트랜잭션을 지원하지 않으며, 생성 또는 변경 도중 Mysql서버의 비정상적 종료 시 DB, Table이 깨졌다.
 8.0부터는 테이블의 구조, 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선
Mysql	TABLE_CATALOG	TABLE_SCHEMA		TABLE_NAME		TABLE_TYPE	ENGINE		VERSION		ROW_FORMAT
8.0 	def		mysql			innodb_table_stats	BASE TABLE	InnoDB		10		Dynamic
5.6 	def		information_schema	CHARACTER_SETS		SYSTEM VIEW	MEMORY		10		Fixed
실행한 query ( select * from information_schema.tables limit 1; )
비교해보니 8.0에서 information_schema.tables는 mysql를 참조(뷰)하고 있었고, ENGINE 컬럼 또한 InnoDB에 실제 저장되고 있었다.
 아마 8.0부턴 트랜잭션 기준으로 스키마 변경 성공, 실패로 데이터가 남아있을 것이다.
++ InnoDB이외의 스토리지 엔진(MyISAM, CSV)을 사용하는 테이블들은 메타데이터 저장을 위해 SDI(Serialized Dictionary Information) 파일을 사용하며 *.FRM 파일과 동일한 역할을 한다. 
   ibd2sdi 유틸리티 사용 InnoDB 테이블 스페이스에서 스키마 정보를 추출 - P97 사용방법
   
InnoDB는 Mysql의 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금 제공 + 높은 동시성 처리
InnoDB의 모든 테이블은 기본적으로 Primary key를 기준으로 클러스터링 저장. 즉 Primary key는 다른 보조 인덱스에 비해 비중이 높고,
Oracle DBMS의 IOT와 동일한 구조가 됨.
MyISAM은 클러스터링 키를 지원하지 않아 Primary key와 Secondary Index의 구조는 차이가 없고, 모든 인덱스는 물리적 레코드 주소 값을 가진다.

외래 키 지원 - InnoDB 스토리지 엔진 레벨에서 지원, MyISAM, MEMORY 테이블에선 사용 불가 
foreign_key_checks = OFF 외래 키 관계 체크 OFF

MVCC(Multi Version Concurrency Control) - 레코드 레벨의 트랜잭션 지원하는 DBMS가 제공하는 기능, 잠금을 사용하지 않는 일관된 읽기를 제공
InnoDB - Undo log를 이용해서 기능 구현 // Multi Version - 하나의 레코드에 대해 여러 개의 버전이 관리 됨 
ex) 레코드를 UPDATE 했을때 새로운 값은 버퍼 풀에 기록되고, Undo log에 기존의 레코드가 기록된다. 그 이후 시스템 변수에 설정 된 격리 수준에 따라 반환 값이 달라진다. 
이후 COMMIT, ROLLBACK으로 확정 짓고 Undo 영역은 삭제된다( 필요로 하는 트랜잭션이 더는 없을 때 )

잠금 없는 일관된 읽기 
InnoDB는 MVCC를 이용해 잠금을 걸지 않고 읽기 작업을 수행
INSERT 가  걸려 있어도 Undo log를 통해 SELECT을 수행한다. 하지만 트랜잭션이 오래 될 경우 삭제되지 못한 Undo log때문에 Mysql서버가 느려지거나 문제가 발생 할 수 있다.

자동 데드락 감지
InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프형태로 관리한다.
데드락 감지 스레드는 주기적으로 잠금 대기 그래프를 검사하고, 트랜잭션의 Undo log의 양으로 교착상태에 빠진 트랜잭션을 강제 종료한다. (양이 더 적으면 롤백의 대상이 됨)
innodb_table_locks 활성화 시 엔진 내부의 레코드 잠금뿐만 아니라, 테이블 레벨의 잠금까지 감지 가능
하지만, 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수 있음.
innodb_deadlock_detect = OFF (데드락 감지 스레드 On/Off)
innodb_lock_wait_timeout 활성화 시 데드락 상황에서 설정 시간이 지나면 에러 메시지 반환 deadlock off 시 -> timeout 50이하 권장 

자동화된 장애복구
Innodb는 mysql 서버 시작 시 항상 자동 복구를 수행한다. 만약 자동으로 복구될 수 없는 손상이 있다면, 자동 복구는 멈추고 mysql 서버는 종료된다.
이 경우 innodb_force_recovery 설정 후 복구 시작 필요 ( 복구모드에선 select 이외 불가, 숫자가 커질 수록 심각한 상황 )

1(SRV_FORCE_IGNORE_CORRUPT) - Database page 손상 관련
InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 Mysql서버를 시작한다.
에러 로그 파일에 'Database page corruption on disk or a failed' 메시지 출력 될 때 대부분 해당

2(SRV_FORCE_NO_BACKGROUND) - 메인 스레드 Undo data 삭제 장애 관련
백그라운드 스레드 중 메인 스레드를 시작하지 않고 Mysql을 시작한다. 
InnoDB의 메인 스레드가 Undo data를 삭제하는 과정에서 장애가 발생했다면 이 모드로 복구하면 된다.

3(SRV_FORCE_NO_TRX_UNDO) - 트랜잭션 커밋 관련
정상적인 Mysql 서버의 시작에서는 최종적으로 커밋되지 않은 트랜잭션은 롤백을 수행한다.
커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 Mysql 서버를 시작하는 모드

4(SRV_FORCE_NO_IBUF_MERGE) - 인서트 버퍼 병합 관련
InnoDB는 INSERT, UPDATE, DELETE 등의 데이터 변경으로 인한 '인덱스 변경 작업'을 상황에 따라 즉시 처리할 수도, 인서트 버퍼에 저장해두고 나중에 처리 할 수도 있다.
Mysql을 종료했을 때 인서트 버퍼에 기록된 내용은 데이터 파일에 병합되지 않을 수 있는데, 재시작하면서, 인서트 버퍼의 손상을 감지하면
InnoDB는 에러를 발생시키고 서버는 시작하지 못한다. 
4로 설정할 경우 인서트 버퍼의 내용을 무시하고 강제로 Mysql이 시작되게 한다.

5(SRV_FORCE_NO_UNDO_LOG_SCAN) - Undo log 관련
Mysql의 재시작 시 InnoDB의 Undo log를 사용할 수 없다면 InnoDB 엔진의 에러로 서버 시작이 불가능하다.
5 설정 시 Undo log를 모두 무시하고 시작한다.
하지만 이 모드로 복구 시 서버 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되므로 잘못된 데이터에 대한 확인이 필요하다.

6(SRV_FORCE_NO_LOG_REDO) - Redo log 관련
Redo log 손상 시 서버가 시작되지 못한다. 
6 설정 시 Redo log를 모두 무시하고 시작된다. 커밋됐다 하더라도 Redo log에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시된다. 
'마지막 체크포인트 시점의 데이터만 남게 된다.'
기존의 Redo log는 모두 삭제(백업 후)하고 Mysql를 시작하는 것이 좋다. 


InnoDB 버퍼 풀 
스토리지 엔진에서 가장 핵심적인 부분. 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게
해주는 버퍼 역할도 같이 한다. 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

버퍼 풀의 크기 설정은 OS와 각 클라이언트 스레드가 사용할 메모리도 고려해서 설정해야 한다.
독특한 경우 레코드 버퍼가 상당한 메모리를 사용하기도 한다. 레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간을 말하는데, 
커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 많이 필요해질 수도 있다.

5.7부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있고, 가능하다면 적절히 작은 값으로 설정 후 증가 시키는게 최적이다.
8GB 미만이라면 50%, 그 이상이라면 50%부터 시작해서 조금씩 올라가면서, 50GB 이상이라면, 대략 15~30GB정도를 남겨두고 나머지를 버퍼 풀로 할당하는 것이 좋다. 
버퍼 풀 사이즈 설정 - innodb_buffer_pool_size (크기 변경은 크리티컬한 변경이므로, 서버가 한가한 시점에 진행하는 것이 좋음)
버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리된다. (크기를 줄이거나 늘릴 때 128MB 단위로 처리 됨)

버퍼 풀은 전체를 관리하는 잠금(세마포어)에서 내부 잠금 경합을 줄이기 위해 여러개로 쪼개어 관리 할수 있게 개선됐다
버퍼 풀로 할당할 수 있는 메모리 공간이 40GB 이하 수준이라면 기본값 8을 유지 - innodb_buffer_pool_instances 
메모리가 크다면 버퍼 풀 인스턴스당 5GB 정도가 되게 설정하는 것이 좋다.

버퍼 풀의 구조 


