< 트랜잭션 >
잠금 - 동시성을 제어하기 위한 기능
트랜잭션 - 데이터 정합성을 보장하기 위한 기능

Mysql에서의 트랜잭션
** 하나의 논리적인 작업 셋에 쿼리의 갯수와 상관 없이 작업 셋 자체가 100%로 적용 되거나(COMMIT)
아무것도 적용되지 않아야 함을 보장해주는 것이다. **
MyISAM과 InnoDB에서의 작업 비교
1) Table을 만들고 3(pk)을 insert 한다. 
2) 1, 2, 3 insert
3) MyISAM은 1,2는 insert 되고 3에서 쿼리 중단 // InnoDB는 쿼리 자체가 중단
* MyISAM에서 Partial Update(부분 업데이트)가 일어나게 된다.

주의사항 - 프로그램 코드에서 트랜잭션의 범위를 최소화해야 한다.
DBMS의 트랜잭션은 저장되는 부분을 넣고
메일 전송, FTP 파일전송 등 네트워크 통신 관련은 제거, 
성격이 다른 것도 구분해서 범위 수정해야 한다. 

Mysql 엔진의 잠금
Mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다. 

글로벌 락 - FLUSH TABLES WITH READ LOCK // 범위가 가장 큰 잠금 
범위 - Mysql 서버 전체, DDL DML 실행 대기(SELECT 제외) 
테이블이나 데이터베이스가 달라도 동일하게 영향을 미친다.
또한, 락을 획득하기 위해서는 모든 종류의 쿼리가 완료되어야 한다.
8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성 이 생겼다.
Xtrabackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입 됐다.
mysql> LOCK INSTANCE FOR BACKUP; // 실행
mysql> UNLOCK INSTANCE;
특정 세션에서 백업 락을 획득 시 다음과 같은 정보 변경 불가
- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

하지만 일반적인 테이블의 데이터 변경은 허용.

테이블 락 - 개별 테이블 단위로 설정되는 잠금 
명시적 : LOCK TABLES table_name [ READ | WRITE ] // UNLOCK TABLES 
묵시적 : MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
        InnoDB) 스토리지 엔진 차원에서 레코드 기반의 잠금 제공 & 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마 변경하는 DDL의 경우에만 영향을 미침

네임드 락 - GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정. 단순히 사용자가 지정한 문자열에 대해 획득하고 반납(해제)
많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용. (8.0부터 네임드 락 중첩가능, 한 번에 해제 가능 )

메타데이터 락 - 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금. 명시적 획득 불가
RENAME TABLE tab_a TO tab_b // 원본 이름, 변경될 이름 모두 한꺼번에 잠금
ex) 임시 rank_new를 rank로 올리기 위해 이름 변경할 경우 
mysql> RENAME TABLE rank TO rank_backup, rank_new TO rank; // 한 꺼번에 실행 시 table not found없이 가능 

트랜잭션과 같이 사용할 경우 : +트랜잭션 +key_block_size (p166)

InnoDB 스토리지 엔진 잠금
Mysql에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재 -> MyISAM보다 훨씬 뛰어난 동시성 처리 제공
But) 이원화된 잠금 처리 탓에 잠금 정보는 Mysql 명령을 이용해 정보를 접근하기 까다로움 
1) lock_monitor
2) SHOW ENGINE INNODB STATUS

최근 버전에서는 InnoDB의 트랜잭션, 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회 할 수 있음
information_schema [ INNODB_TRX, TNNODB_LOCKS, INNODB_LOCK_WAITS ] 조인해서 조회
performance_schema를 이용해 스토리지 엔진의 내부 잠금에 대한 모니터링 방법도 추가 

락 그림 (p167)
레코드 락 - 레코드 자체만 잠그는 것을 레코드 락, 다른 상용 DBMS의 레코드 락과 동일한 역할
하지만, InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다 *
인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

갭 락
레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것 
레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것 

넥스트 키 락
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
STATEMENT 포맷의 binlog를 사용하는 Mysql서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다. 
innodb_locks_unsafe_for_binlog 변수 비활성화 시 변경을 위해 검색을 하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
갭 락, 넥스트 키 락은 binlog에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다 .
가능하다면 binlog_format을 ROW로 바꿔서 넥스트 키 락이나 갭 락을 줄이는게 좋다 
** binlog_format [ MIXED | ROW ] 에 대한 고찰, 성능은 ROW가 좋지만 안정성에 대한 문제?? **

자동 증가 락
자동 증가하는 숫자 값을 추출하기 위해 내부적으로 AUTO_INCREMENT 락 ( 테이블 수준의 잠금 )
INSERT, REPLACE 새로운 레코드를 저장하는 쿼리에서만 필요
UPDATE, DELETE 쿼리에서는 걸리지 않음
명시적으로 획득, 해제 방법은 없음
(5.1 이후)
innodb_autoinc_lock_mode = 0
5.0과 동일한 잠금 방식, 모든 INSERT 문장은 자동 증가 락을 사용

innodb_autoinc_lock_mode = 1 
1) Mysql서버가 INSERT되는 레코드의 건수를 정확히 예측할 수 있을때는 자동 증가 락을 사용하지 않고, 훨씬 가볍고 빠른 래치(Mutex)를 이용해 처리 - 아주 짧은 시간 동안만 잠금을 걸고 필요한 자동 증가 값을 가져오면 즉시 잠금이 해제.
2) 예측 할 수 없으면 자동 증가 락 사용

한 번에 할당 받은 자동 증가 값이 남아서 사용되지 못하면 폐기하므로, 대량 INSERT 문장의 실행 이후에 INSERT 되는 레코드의 자동 증가 값은 연속되지 않고 누락된 값이 발생할 수 있다.
최소한 하나의 INSERT 문장으로 INSERT되는 레코드는 연속된 자동 증가 값을 가지게 된다. 그래서 연속모드 라고도 한다.

innodb_autoinc_lock_mode = 2
절대 자동 증가 락을 걸지 않고 경량화된 래치를 사용. 하나의 INSERT 문장으로 INSERT되는 레코드라고 하더라도 연속된 자동 증가 값을 보장하진 않는다. 그래서 인터리빙 모드라고도 한다.
INSERT 중에 다른 커넥션에서 INSERT 수행 가능, 유니크한 값이 생성된다는 것만 보장한다. 
--> STATEMENT 포맷 Replication에서 자동 증가 값이 달라질 수 있음에 주의 *
(5.7까지는 default 1, 8.0부터는 default 2 : 이유는 binlog_format default가 ROW가 돼서. STATEMENT 사용시 innodb_autoinc_lock_mode = 1 권장 )

인덱스와 잠금 - innodb의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.
ex) ix_firstname 인덱스가 있고, first_name = 'Georgi' 사원 253명 , first_name = 'Georgi' & last_name = 'Klassen' 사원 1명 전제
first_name = 'Georgi' & last_name = 'Klassen'인 사원의 hire_date를 UPDATE한다면 락을 걸어야하는 레코드의 개수는 ?
-> 253개 레코드 락
만약 ix_firstname 인덱스가 없었다면 위의 UPDATE를 하기 위해선 해당 테이블을 풀스캔하여 전체 락을 걸었어야 함. 인덱스의 중요성 !

레코드 수준의 잠금 확인 및 해제
레코드 수준의 잠금은 레코드 각각에 잠금이 걸리므로, 자주 사용하지 않는 레코드라면, 발견되지 않고 남아 있을 수 있음.
5.1 이후)
information_schema. INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS
8.0 이후)
performance_schema. data_locks, data_lock_waits

8.0)
select r.trx_id as waiting_trx_id, 
       r.trx_mysql_thread_id as waiting_thread, // 기다리는 thread 
       r.trx_query as waiting_query,
       b.trx_id as blocking_trx_id,
       b.trx_mysql_thread_id as blocking_thread, // 해당 thread가 기다리고 있는 thread
       b.trx_query as blocking_query
  from performance_schema.data_lock_waits w inner join information_schema.innodb_trx b
    on b.trx_id = w.blocking_engine_transaction_id inner join information_schema.innodb_trx r
    on r.trx_id = w.requesting_engine_transaction_id;

select * from information_schema.INNODB_TRX;










