< 트랜잭션 >
잠금 - 동시성을 제어하기 위한 기능
트랜잭션 - 데이터 정합성을 보장하기 위한 기능

Mysql에서의 트랜잭션
** 하나의 논리적인 작업 셋에 쿼리의 갯수와 상관 없이 작업 셋 자체가 100%로 적용 되거나(COMMIT)
아무것도 적용되지 않아야 함을 보장해주는 것이다. **
MyISAM과 InnoDB에서의 작업 비교
1) Table을 만들고 3(pk)을 insert 한다. 
2) 1, 2, 3 insert
3) MyISAM은 1,2는 insert 되고 3에서 쿼리 중단 // InnoDB는 쿼리 자체가 중단
* MyISAM에서 Partial Update(부분 업데이트)가 일어나게 된다.

주의사항 - 프로그램 코드에서 트랜잭션의 범위를 최소화해야 한다.
DBMS의 트랜잭션은 저장되는 부분을 넣고
메일 전송, FTP 파일전송 등 네트워크 통신 관련은 제거, 
성격이 다른 것도 구분해서 범위 수정해야 한다. 

Mysql 엔진의 잠금
Mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지는 않는다. 

글로벌 락 - FLUSH TABLES WITH READ LOCK // 범위가 가장 큰 잠금 
범위 - Mysql 서버 전체, DDL DML 실행 대기(SELECT 제외) 
테이블이나 데이터베이스가 달라도 동일하게 영향을 미친다.
또한, 락을 획득하기 위해서는 모든 종류의 쿼리가 완료되어야 한다.
8.0부터는 InnoDB가 기본 스토리지 엔진으로 채택되면서 조금 더 가벼운 글로벌 락의 필요성 이 생겼다.
Xtrabackup, Enterprise Backup과 같은 백업 툴들의 안정적인 실행을 위해 백업 락이 도입 됐다.
mysql> LOCK INSTANCE FOR BACKUP; // 실행
mysql> UNLOCK INSTANCE;
특정 세션에서 백업 락을 획득 시 다음과 같은 정보 변경 불가
- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- REPAIR TABLE과 OPTIMIZE TABLE 명령
- 사용자 관리 및 비밀번호 변경

하지만 일반적인 테이블의 데이터 변경은 허용.

테이블 락 - 개별 테이블 단위로 설정되는 잠금 
명시적 : LOCK TABLES table_name [ READ | WRITE ] // UNLOCK TABLES 
묵시적 : MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
        InnoDB) 스토리지 엔진 차원에서 레코드 기반의 잠금 제공 & 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마 변경하는 DDL의 경우에만 영향을 미침

네임드 락 - GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정. 단순히 사용자가 지정한 문자열에 대해 획득하고 반납(해제)
많은 레코드에 대해서 복잡한 요건으로 레코드를 변경하는 트랜잭션에 유용하게 사용. (8.0부터 네임드 락 중첩가능, 한 번에 해제 가능 )

메타데이터 락 - 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금. 명시적 획득 불가
RENAME TABLE tab_a TO tab_b // 원본 이름, 변경될 이름 모두 한꺼번에 잠금
ex) 임시 rank_new를 rank로 올리기 위해 이름 변경할 경우 
mysql> RENAME TABLE rank TO rank_backup, rank_new TO rank; // 한 꺼번에 실행 시 table not found없이 가능 

트랜잭션과 같이 사용할 경우 : +트랜잭션 +key_block_size (p166)

InnoDB 스토리지 엔진 잠금
Mysql에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재 -> MyISAM보다 훨씬 뛰어난 동시성 처리 제공
But) 이원화된 잠금 처리 탓에 잠금 정보는 Mysql 명령을 이용해 정보를 접근하기 까다로움 
1) lock_monitor
2) SHOW ENGINE INNODB STATUS

최근 버전에서는 InnoDB의 트랜잭션, 잠금, 잠금 대기 중인 트랜잭션의 목록을 조회 할 수 있음
information_schema [ INNODB_TRX, TNNODB_LOCKS, INNODB_LOCK_WAITS ] 조인해서 조회
performance_schema를 이용해 스토리지 엔진의 내부 잠금에 대한 모니터링 방법도 추가 

락 그림 (p167)
레코드  - 레코드 자체만으 잠그는 것을 레코드 락, 다른 상용 DBMS의 레코드 락과 동일한 역할
하지만, InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다 *
인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.

갭 락
레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것 
레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것 

넥스트 키 락
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
STATEMENT 포맷의 binlog를 사용하는 Mysql서버에서는 REPEATABLE READ 격리 수준을 사용해야 한다. 
innodb_locks_unsafe_for_binlog 변수 비활성화 시 변경을 위해 검색을 하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸린다.
갭 락, 넥스트 키 락은 binlog에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다 .
가능하다면 binlog_format을 ROW로 바꿔서 넥스트 키 락이나 갭 락을 줄이는게 좋다 
** binlog_format [ MIXED | ROW ] 에 대한 고찰, 성능은 ROW가 좋지만 안정성에 대한 문제?? **

자동 증가 락


